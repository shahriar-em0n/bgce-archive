<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Golang046 Go Runtime - BGCE ARCHIVE</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../../../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>тЖР</kbd> or <kbd>тЖТ</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">BGCE ARCHIVE</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/NesoHQ/bgce-archive.git" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="class-46---go-runtime"><a class="header" href="#class-46---go-runtime">Class 46 : ЁЯР╣ Go Runtime</a></h1>
<h2 id="-guide-to-ram-kernel-space-vs-user-space"><a class="header" href="#-guide-to-ram-kernel-space-vs-user-space">ЁЯза Guide to RAM: Kernel Space vs User Space</a></h2>
<p>ржХржорзНржкрж┐ржЙржЯрж╛рж░ ржЪрж╛рж▓рзБ рж╣рж▓рзЗ RAM (Random Access Memory) ржХрзЗ ржжрзБржЗржЯрж╛ ржнрж╛ржЧрзЗ ржнрж╛ржЧ ржХрж░рж╛ рж╣ржпрж╝:</p>
<ul>
<li>ЁЯЫбя╕П <strong>Kernel Space</strong></li>
<li>ЁЯСитАНЁЯТ╗ <strong>User Space</strong></li>
</ul>
<h2 id="-kernel-space"><a class="header" href="#-kernel-space">ЁЯЫбя╕П Kernel Space:</a></h2>
<p>ржПржЯрж╛ Operating System (OS) ржПрж░ ржирж┐ржЬрзЗрж░ ржЬржирзНржп allocated space</p>
<p>ржПржЦрж╛ржирзЗ ржерж╛ржХрзЗ:</p>
<ul>
<li>OS ржПрж░ ржорзВрж▓ ржХрзЛржб (kernel code)</li>
<li>kernel data structures</li>
<li>page table (memory mapping ржПрж░ ржЬржирзНржп)</li>
</ul>
<blockquote>
<p>Kernel рж╕ржм ржХрж┐ржЫрзБ access ржХрж░рждрзЗ ржкрж╛рж░рзЗред</p>
</blockquote>
<h3 id="-why-its-protected"><a class="header" href="#-why-its-protected">ЁЯФР Why it's protected?</a></h3>
<ul>
<li>ржпрж╛рждрзЗ user program ржЧрзБрж▓рзЛ kernel ржПрж░ sensitive ржЕржВрж╢рзЗ ржнрзБрж▓ ржХрж░рзЗ ржмрж╛ ржЗржЪрзНржЫрж╛ ржХрж░рзЗ access ржХрж░рждрзЗ ржирж╛ ржкрж╛рж░рзЗред</li>
<li>Security ржЖрж░ stability ржПрж░ ржЬржирзНржпред</li>
</ul>
<h3 id="-access-from-user-programs"><a class="header" href="#-access-from-user-programs">ЁЯзй Access from user programs</a></h3>
<ul>
<li>User program ржпржжрж┐ OS ржПрж░ help ржЪрж╛рзЯ, рждржЦржи system call ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ (ржпрзЗржоржи <code>read()</code>, <code>write()</code>, <code>open()</code>).</li>
<li>рждржЦржи ржПржХржЯрж╛ software interrupt (ржпрзЗржоржи <code>0x80</code>) рждрзИрж░рж┐ рж╣ржпрж╝ред</li>
<li>ржПрждрзЗ CPU <em>user mode</em> ржерзЗржХрзЗ <em>kernel mode</em> ржП ржпрж╛рзЯ, kernel ржХрж╛ржЬржЯрж╛ ржХрж░рзЗ ржжрж┐рзЯрзЗ ржЖржмрж╛рж░ ржлрж┐рж░рзЗ ржЖрж╕рзЗред</li>
</ul>
<h3 id="-kernel-stack"><a class="header" href="#-kernel-stack">ЁЯз╡ Kernel Stack</a></h3>
<ul>
<li>ржпржЦржи kernel ржХрж╛ржЬ ржХрж░рзЗ, рждржЦржи ржПржХржЯрж╛ kernel stack ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗред</li>
<li>ржПржЯрж╛ рж╕ржм process ржорж┐рж▓рзЗ share ржХрж░рзЗред</li>
</ul>
<h2 id="-user-space"><a class="header" href="#-user-space">ЁЯСитАНЁЯТ╗ User Space:</a></h2>
<p>RAM ржПрж░ ржПржЗ space тЖТ user application (ржпрзЗржоржи browser, notepad) ржПрж░ ржЬржирзНржпред</p>
<p>ржкрзНрж░рждрж┐ржЯрж╛ process рждрж╛рж░ ржирж┐ржЬрзЗрж░ ржПржХржЯрж╛ <em>virtual memory</em> ржкрж╛рзЯред</p>
<p>ржПрж░ ржоржзрзНржпрзЗ ржерж╛ржХрзЗ:</p>
<ul>
<li><strong>Code:</strong> ржкрзНрж░рзЛржЧрзНрж░рж╛ржорзЗрж░ instruction</li>
<li><strong>Data:</strong> global ржмрж╛ static variables</li>
<li><strong>Heap:</strong> dynamic memory allocation (ржпрзЗржоржи <code>malloc</code>)</li>
<li><strong>Stack:</strong> function call ржЖрж░ local variables</li>
</ul>
<blockquote>
<p>тЪая╕П ржПржЗ space ржерзЗржХрзЗ kernel space рж╕рж░рж╛рж╕рж░рж┐ access ржХрж░рж╛ ржпрж╛рзЯ ржирж╛ред</p>
</blockquote>
<h2 id="-system-call"><a class="header" href="#-system-call">ЁЯзй System Call</a></h2>
<ul>
<li>System Call рж╣рж▓рзЛ ржПржХржзрж░ржирзЗрж░ function call</li>
<li>ржПрж░ ржорж╛ржзрзНржпржорзЗ ржХрзЛржи user program, Operating System ржПрж░ kernel ржерзЗржХрзЗ ржХрзЛржи service ржЪрж╛рзЯ</li>
<li>System Call ржПрж░ рж╕рж╛рж╣рж╛ржпрзНржп user mode ржерзЗржХрзЗ kernel mode ржП рж╕рзБржЗржЪ ржХрж░рзЗ OS ржПрж░ ржмрж┐рж╢рзЗрж╖ ржХрж╛ржЬржЧрзБрж▓рзЛ ржХрж░рж╛рж░ ржЕржирзБржорждрж┐ ржжрзЗржпрж╝</li>
</ul>
<h3 id="-user-mode-vs-kernel-mode"><a class="header" href="#-user-mode-vs-kernel-mode">тЪЩя╕П User Mode vs Kernel Mode</a></h3>
<ul>
<li>рж╕рж╛ржзрж╛рж░ржгржнрж╛ржмрзЗ program ржЪрж▓рзЗ user mode ржП, ржпрзЗржЦрж╛ржирзЗ resource access рж╕рзАржорж┐ржд ржерж╛ржХрзЗред</li>
<li>ржХрзЛржи special ржХрж╛ржЬ (ржпрзЗржоржи file read/write, process рждрзИрж░рж┐) ржХрж░рждрзЗ рж╣рж▓рзЗ system call ржжрж┐рждрзЗ рж╣рзЯ, рждржЦржи program kernel mode ржП ржпрж╛рзЯред</li>
</ul>
<h2 id="-intro-to-go-runtime"><a class="header" href="#-intro-to-go-runtime">тЬи Intro to Go Runtime</a></h2>
<pre><code class="language-bash">go build main.go
</code></pre>
<p>Go compiler:</p>
<ul>
<li>main.go ржлрж╛ржЗрж▓ржЯрж╛ compile ржХрж░рзЗ</li>
<li>рждрж╛рж░ржкрж░ ржПржХржЯрж╛ binary executable file рждрзИрж░рж┐ ржХрж░рзЗ - рж╕рж╛ржзрж╛рж░ржгржнрж╛ржмрзЗ рж╕рзЗржЯрж╛ рж╣рзЯ <code>main</code> ржирж╛ржорзЗ (Linux/Unix-ржП)</li>
</ul>
<pre><code class="language-bash">./main
</code></pre>
<p>ржПржХржЯрж╛ process create рж╣рзЯ</p>
<p><strong>ЁЯФБ рж╕ржВржХрзНрж╖рзЗржкрзЗ flow:</strong></p>
<pre><code class="language-plaintext">go build main.go   тЖТ  main (binary file)
./main             тЖТ  OS creates a process
                   тЖТ  program runs
</code></pre>
<h3 id="-main-stack-ржПржмржВ-stack-frame"><a class="header" href="#-main-stack-ржПржмржВ-stack-frame">ЁЯУж Main Stack ржПржмржВ Stack Frame</a></h3>
<ul>
<li>Main thread ржПрж░ ржЬржирзНржп ржПржХржЯрж┐ stack рждрзИрж░рж┐ рж╣рзЯ - ржПржЯрж╛ржХрзЗ ржмрж▓рзЗ main stackред</li>
<li>Go runtime ржПрж░ function ржЧрзБрж▓рзЛрж░ ржЬржирзНржп ржПржЗ main stack ржП stack frames рждрзИрж░рж┐ рж╣рзЯред</li>
<li>Main thread тЖТ execute тЖТ go runtime stack</li>
</ul>
<p><strong>ЁЯФ╣ Stack Frame:</strong>
ржкрзНрж░рждрж┐ржЯрж╛ function call ржПрж░ ржЬржирзНржп ржПржХржЯрж╛ stack frame рждрзИрж░рж┐ рж╣рзЯред</p>
<p>Stack frame ржПрж░ ржоржзрзНржпрзЗ ржерж╛ржХрзЗ:</p>
<ul>
<li>function ржПрж░ local variables,</li>
<li>return address (function рж╢рзЗрж╖рзЗ ржХрзЛржерж╛рзЯ ржлрж┐рж░рзЗ ржпрж╛ржмрзЗ),</li>
<li>ржХрж┐ржЫрзБ runtime bookkeeping dataред</li>
</ul>
<p><strong>ЁЯФ╣Go Runtime -</strong></p>
<ul>
<li>Memory allocate</li>
<li>Set up тЖТ Stack &amp; Heap</li>
<li>Initialize тЖТ Go Scheduler</li>
<li>Go Runtime тЖТ System Call тЖТ Kernel тЖТ <code>epoll_create</code></li>
</ul>
<h3 id="-what-is-epoll-in-linux"><a class="header" href="#-what-is-epoll-in-linux">ЁЯМА What is epoll in Linux?</a></h3>
<ul>
<li><code>epoll</code> рж╣рж▓рзЛ Linux kernel ржПрж░ ржПржХржЯрж┐ I/O <em>event notification system</em></li>
<li>ржПржЯрж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ рж╣рзЯ ржПржХрж╕рж╛ржерзЗ ржЕржирзЗржХржЧрзБрж▓рзЛ <em>file descriptor (fd)</em> ржПрж░ ржУржкрж░ efficiently ржиржЬрж░ рж░рж╛ржЦрж╛рж░ ржЬржирзНржпред</li>
</ul>
<blockquote>
<p>ржПржЯрж┐ <code>select()</code> ржмрж╛ <code>poll()</code> ржПрж░ ржерзЗржХрзЗ ржЖрж░ржУ scalable, efficient, ржПржмржВ fasterред</p>
</blockquote>
<p>Linux-ржПрж░ epoll ржПрж░ ржорждрзЛ high-performance I/O event notification mechanisms ржЕржирзНржп OS-ржЧрзБрж▓рзЛрждрзЗржУ ржЖржЫрзЗ</p>
<h4 id="-macos-darwinbsd--kqueue"><a class="header" href="#-macos-darwinbsd--kqueue">ЁЯЦея╕П MacOS (Darwin/BSD) тЮд kqueue</a></h4>
<ul>
<li>Equivalent of epoll in macOS is kqueue.</li>
<li>ржПржЯрж┐ BSD-based systems (macOS, FreeBSD, OpenBSD) ржП ржмрзНржпржмрж╣рзГржд рж╣рзЯред</li>
</ul>
<h4 id="-windows--iocp-io-completion-ports"><a class="header" href="#-windows--iocp-io-completion-ports">ЁЯкЯ Windows тЮд IOCP (I/O Completion Ports)</a></h4>
<ul>
<li>Windows-ржПрж░ equivalent рж╣рж▓ тЮд IOCP (I/O Completion Ports)ред</li>
</ul>
<p><strong>ЁЯФ╣ IOCP-ржПрж░ ржХрж╛ржЬ:</strong></p>
<ul>
<li>Asynchronous I/O operations handle ржХрж░рждрзЗ ржмрзНржпржмрж╣рзГржд рж╣рзЯред</li>
<li>Efficient ржПржмржВ scalable, especially high-performance servers-ржПрж░ ржЬржирзНржпред</li>
</ul>
<h3 id="-epoll-ржХржмрзЗ-ржжрж░ржХрж╛рж░-рж╣рзЯ"><a class="header" href="#-epoll-ржХржмрзЗ-ржжрж░ржХрж╛рж░-рж╣рзЯ">ЁЯза epoll ржХржмрзЗ ржжрж░ржХрж╛рж░ рж╣рзЯ?</a></h3>
<ul>
<li>Network socket</li>
<li>File</li>
<li>Pipe</li>
</ul>
<p>ржЗрждрзНржпрж╛ржжрж┐ ржПржХрж╕рж╛ржерзЗ monitor ржХрж░рждрзЗ ржПржмржВ ржХрзЛржиржЯрж╛ read/write ржПрж░ ржЬржирзНржп ready рж╣рзЯрзЗржЫрзЗ</p>
<pre><code class="language-plaintext">epfd = epoll_create1(0);                // epoll instance рждрзИрж░рж┐
epoll_ctl(epfd, ADD, sockfd, &amp;event);   // ржХрзЛржи socket watch ржХрж░ржмрзЛ?
epoll_wait(epfd, events, MAX, timeout); // wait ржХрж░ржмрзЛ ржХржЦржи data ржЖрж╕ржмрзЗ
</code></pre>
<h3 id="-epoll-ржПрж░-ржЬржиржп-ржмржпржмрж╣рзГржд-рзйржЯрж┐-main-syscall"><a class="header" href="#-epoll-ржПрж░-ржЬржиржп-ржмржпржмрж╣рзГржд-рзйржЯрж┐-main-syscall">ЁЯФз epoll ржПрж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГржд рзйржЯрж┐ main syscall</a></h3>
<p><strong><code>epoll_create</code> / <code>epoll_create1</code></strong></p>
<ul>
<li>ржПржХржЯрж┐ ржирждрзБржи epoll instance рждрзИрж░рж┐ ржХрж░рзЗ ржПржмржВ ржПржХржЯрж┐ file descriptor (fd) рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЗред</li>
<li>ржПржЗ fd ржХрзЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржЖржкржирж┐ ржкрж░ржмрж░рзНрждрзАрждрзЗ ржЗржнрзЗржирзНржЯ monitor ржХрж░ржмрзЗржиред</li>
</ul>
<p><strong><code>epoll_ctl</code></strong></p>
<ul>
<li>epoll instance ржП ржХрзЛржи file descriptor monitor ржХрж░рждрзЗ рж╣ржмрзЗ рж╕рзЗржЯрж╛ ржмрж▓рзЗ ржжрзЗрзЯред</li>
<li>ржЕрж░рзНржерж╛рзО: add / modify / delete operationред</li>
</ul>
<p><strong><code>epoll_wait</code></strong></p>
<ul>
<li>ржПржЯрж┐ block ржХрж░рзЗ (ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗ) ржпрждржХрзНрж╖ржг ржирж╛ ржХрзЛржи monitored file descriptor ржерзЗржХрзЗ I/O event ржЖрж╕рзЗред</li>
<li>ржпржЦржи ржЖрж╕рзЗ, рждржЦржи рж╕рзЗржЗ event return ржХрж░рзЗ ржжрзЗрзЯред</li>
</ul>
<h3 id="-scenario-epoll-based-non-blocking-file-read-in-linux"><a class="header" href="#-scenario-epoll-based-non-blocking-file-read-in-linux">ЁЯП╖я╕П Scenario: epoll-based Non-blocking File Read in Linux</a></h3>
<p><strong>Process &amp; Threads</strong></p>
<ul>
<li>P1: T1, T2</li>
<li>P2: T1</li>
<li>P3: T1, T2, T3</li>
</ul>
<p>P1-T1 ржПржХржЯрж┐ ржлрж╛ржЗрж▓ ржкрзЬрждрзЗ ржЪрж╛рзЯ, ржЕрж░рзНржерж╛рзО I/O operation ржХрж░рждрзЗ ржЪрж╛рзЯред</p>
<p>ржЖржорж░рж╛ ржзрж░ржЫрж┐ ржПржЯрж╛ non-blocking I/O ржПржмржВ epoll ржмрзНржпржмрж╣рзГржд рж╣ржЪрзНржЫрзЗ (Linux system)ред</p>
<h4 id="рзз-t1-ржлрж╛ржЗрж▓-ржкрзЬрждрзЗ-ржЪрж╛рзЯ"><a class="header" href="#рзз-t1-ржлрж╛ржЗрж▓-ржкрзЬрждрзЗ-ржЪрж╛рзЯ">рззя╕ПтГг T1 ржлрж╛ржЗрж▓ ржкрзЬрждрзЗ ржЪрж╛рзЯ</a></h4>
<ul>
<li>T1 kernel-ржП read request ржкрж╛ржарж╛рзЯ, ржХрж┐ржирзНрждрзБ ржлрж╛ржЗрж▓ рждржЦржиржУ рж░рзЗржбрж┐ ржирж╛ред</li>
<li>рждрж╛ржЗ T1 ржмрж▓рзЗ, "ржлрж╛ржЗрж▓ рж░рзЗржбрж┐ рж╣рж▓рзЗ ржЖржорж╛ржХрзЗ ржЬрж╛ржирж┐ржУ" тАФ non-blocking mode</li>
</ul>
<h4 id="2-t1-syscall-ржХрж░рзЗ--epoll_ctl"><a class="header" href="#2-t1-syscall-ржХрж░рзЗ--epoll_ctl">2я╕ПтГг T1 syscall ржХрж░рзЗ тЖТ epoll_ctl</a></h4>
<ul>
<li>ржПржЯрж╛ ржжрж┐рзЯрзЗ kernel-ржХрзЗ ржЬрж╛ржирж╛ржирзЛ рж╣рзЯ:</li>
<li>"ржПржЗ ржлрж╛ржЗрж▓рзЗрж░ ржЬржирзНржп ржЖржорж┐ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржмрзЛред ржлрж╛ржЗрж▓ржЯрж╛ read ржХрж░рждрзЗ ржкрж╛рж░рж▓рзЗржЗ ржЖржорж╛ржХрзЗ ржбрж╛ржХрзЛред"</li>
</ul>
<h4 id="3-kernel-t1-ржХрзЗ-ржШрзБржо-ржкрж╛рзЬрж┐рзЯрзЗ-ржжрзЗрзЯ"><a class="header" href="#3-kernel-t1-ржХрзЗ-ржШрзБржо-ржкрж╛рзЬрж┐рзЯрзЗ-ржжрзЗрзЯ">3я╕ПтГг Kernel T1 ржХрзЗ ржШрзБржо ржкрж╛рзЬрж┐рзЯрзЗ ржжрзЗрзЯ</a></h4>
<ul>
<li>ржпрзЗрж╣рзЗрждрзБ ржлрж╛ржЗрж▓ ржПржЦржирзЛ рж░рзЗржбрж┐ ржирж╛, рждрж╛ржЗ kernel T1 ржХрзЗ sleep/wait ржХрж░рж┐рзЯрзЗ ржжрзЗрзЯред</li>
<li>T1 wait queue рждрзЗ ржЪрж▓рзЗ ржпрж╛рзЯ</li>
<li>рждржЦржи P1-ржПрж░ ржЕржирзНржп ржерзНрж░рзЗржб T2, ржмрж╛ ржЕржирзНржп ржкрзНрж░рж╕рзЗрж╕рзЗрж░ ржерзНрж░рзЗржбржЧрзБрж▓рзЛ рж╕рзНржмрж╛ржнрж╛ржмрж┐ржХржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ</li>
</ul>
<h4 id="4-kernel-ржлрж╛ржЗрж▓-ржЪрзЗржХ-ржХрж░рждрзЗ-ржерж╛ржХрзЗ"><a class="header" href="#4-kernel-ржлрж╛ржЗрж▓-ржЪрзЗржХ-ржХрж░рждрзЗ-ржерж╛ржХрзЗ">4я╕ПтГг kernel ржлрж╛ржЗрж▓ ржЪрзЗржХ ржХрж░рждрзЗ ржерж╛ржХрзЗ</a></h4>
<ul>
<li>kernel backend-ржП ржлрж╛ржЗрж▓ ready ржХрж┐ржирж╛ рж╕рзЗржЯрж╛ monitor ржХрж░рзЗред</li>
<li>ржпржЦржи ржлрж╛ржЗрж▓ржЯрж╛ readable рж╣рзЯрзЗ ржпрж╛рзЯ, рждржЦржи kernel ржлрж╛ржЗрж▓ржЯрж╛ load ржХрж░рзЗ, ржПржмржВ ржлрж╛ржЗрж▓рзЗрж░ ржЬржирзНржп file descriptor рждрзИрж░рж┐ ржХрж░рзЗ</li>
</ul>
<h4 id="5-kernel-epoll-ржХрзЗ-notify-ржХрж░рзЗ"><a class="header" href="#5-kernel-epoll-ржХрзЗ-notify-ржХрж░рзЗ">5я╕ПтГг kernel epoll ржХрзЗ notify ржХрж░рзЗ</a></h4>
<ul>
<li>kernel epoll_wait ржХрзЗ ржмрж▓рзЗ: "ржПржЗ file descriptor ржПржЦржи ready"</li>
<li>epoll_wait рждржЦржи рж╕рзЗржЗ FD ржХрзЗ ready list-ржП рж░рж╛ржЦрзЗ</li>
</ul>
<h4 id="6-epoll_wait-thread-ржХрзЗ-ржЬрж╛ржЧрж┐рзЯрзЗ-рждрзЛрж▓рзЗ"><a class="header" href="#6-epoll_wait-thread-ржХрзЗ-ржЬрж╛ржЧрж┐рзЯрзЗ-рждрзЛрж▓рзЗ">6я╕ПтГг epoll_wait Thread ржХрзЗ ржЬрж╛ржЧрж┐рзЯрзЗ рждрзЛрж▓рзЗ</a></h4>
<p><em>epoll_wait ржПрж░ ржХрж╛ржЬ:</em></p>
<ul>
<li>ржпрж╛рж░рж╛ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржЫрж┐рж▓, рждрж╛ржжрзЗрж░ ржЬрж╛ржирж┐рзЯрзЗ ржжрзЗрзЯрж╛ "рждрзЛржорж╛рж░ ржлрж╛ржЗрж▓ рж░рзЗржбрж┐"</li>
<li>T1 ржПржЦржи wake up рж╣рзЯ</li>
</ul>
<h4 id="7-t1-ржПржЦржи-readfd-ржжрж┐рзЯрзЗ-ржлрж╛ржЗрж▓-ржкрзЬрзЗ"><a class="header" href="#7-t1-ржПржЦржи-readfd-ржжрж┐рзЯрзЗ-ржлрж╛ржЗрж▓-ржкрзЬрзЗ">7я╕ПтГг T1 ржПржЦржи read(fd) ржжрж┐рзЯрзЗ ржлрж╛ржЗрж▓ ржкрзЬрзЗ</a></h4>
<ul>
<li>ржПржмрж╛рж░ T1 ржлрж╛ржЗрж▓ржЯрж┐ read ржХрж░рзЗ ржирзЗрзЯ file descriptor ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ</li>
<li>File descriptor ржПржХржЯрж┐ token ржПрж░ ржорждрзЛ ржХрж╛ржЬ ржХрж░рзЗ тАФ ржПржЯрж┐ ржмрж▓рзЗ ржжрзЗрзЯ kernel-ржПрж░ ржХрзЛржи ржЬрж╛рзЯржЧрж╛ ржерзЗржХрзЗ ржлрж╛ржЗрж▓ ржкрзЬрждрзЗ рж╣ржмрзЗ</li>
</ul>
<h3 id="-file-descriptor"><a class="header" href="#-file-descriptor">ЁЯУж File descriptor</a></h3>
<ul>
<li>File descriptor рж╣ржЪрзНржЫрзЗ kernel-ржПрж░ ржПржХржЯрж┐ token ржмрж╛ ID ржпрж╛ file/socket-ржПрж░ represent ржХрж░рзЗред</li>
<li>User-space access ржХрж░рждрзЗ ржкрж╛рж░рзЗ ржирж╛, ржХрж┐ржирзНрждрзБ kernel ржЖрж░ Go runtime, file/socket ржХрзЗ ржЪрж┐ржирзЗ ржлрзЗрж▓рзЗ ржПржЗ FD ржжрж┐рзЯрзЗред</li>
</ul>
<h3 id="-back-to-go-runtime-story"><a class="header" href="#-back-to-go-runtime-story">ЁЯЪА Back to Go Runtime Story</a></h3>
<p><strong>1. Go Runtime рж╢рзБрж░рзБрждрзЗржЗ ржХрзА ржХрж░рзЗ?</strong></p>
<ul>
<li>Go runtime ржирж┐ржЬрзЗрж░ ржоржзрзНржпрзЗ ржПржХржЯрж╛ epoll instance рждрзИрж░рж┐ ржХрж░рзЗ (epoll_create syscall ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ)ред</li>
<li>ржпржЦржи epoll рждрзИрж░рж┐ ржХрж░рзЗ, рждржЦржи kernel-ржХрзЗ ржмрж▓рзЗ ржжрзЗрзЯ ржХрждржЧрзБрж▓рзЛ file descriptor (FD) ржПржХрж╕рж╛ржерзЗ ржкрзЬрждрзЗ ржЪрж╛рзЯ
<ul>
<li>Go Runtime kernel-ржХрзЗ ржмрж▓рзЗ ржжрзЗрзЯ 100 file descriptor (FD) ржПржХрж╕рж╛ржерзЗ ржкрзЬрждрзЗ ржЪрж╛рзЯ</li>
<li>Max 100 FD read ржХрж░рж╛рж░ ржЬржирзНржп <code>epoll_ctl</code> send ржХрж░рж╛ ржпрж╛ржмрзЗ kernel ржПрж░ ржХрж╛ржЫрзЗ</li>
<li>100 FD list ржЖржХрж╛рж░рзЗ epoll_wait thread ржХрзЗ ржжрж┐рзЯрзЗ ржжрж┐ржмрзЗ</li>
<li><code>epoll_wait</code> thread FD list Go runtime ржХрзЗ ржжрж┐рзЯрзЗ ржжрж┐ржмрзЗ</li>
</ul>
</li>
<li>ржПржЗ instance handle ржХрж░рзЗ рж╕ржм network I/O ржмрж╛ file I/O ржЕржкрж╛рж░рзЗрж╢ржиред</li>
<li>ржПрж░ржкрж░ Go runtime ржПржХржЯрж┐ ржЖрж▓рж╛ржжрж╛ OS thread рждрзИрж░рж┐ ржХрж░рзЗ ржпрзЗржЦрж╛ржирзЗ <code>epoll_wait</code> ржмрж╕рзЗ ржерж╛ржХрзЗред ржПржЗ ржерзНрж░рзЗржбржХрзЗ ржмрж▓рж╛ ржпрж╛рзЯ "Netpoller Thread"ред</li>
</ul>
<p><strong>2. ржПржХржЯрж┐ goroutine file/socket read ржХрж░рждрзЗ ржЪрж╛рзЯ</strong></p>
<ul>
<li>main goroutine (ржпрзЗржоржи <code>go func() { conn.Read() }</code>) socket ржерзЗржХрзЗ ржХрж┐ржЫрзБ ржкрзЬрждрзЗ ржЪрж╛рзЯред</li>
<li>ржпржжрж┐ data рждржЦржиржЗ available ржирж╛ ржерж╛ржХрзЗ, Go runtime:
<ul>
<li>ржУржЗ goroutine ржХрзЗ block ржирж╛ ржХрж░рзЗ park (ржШрзБржо ржкрж╛рзЬрж┐рзЯрзЗ) ржжрзЗрзЯред</li>
<li>ржПржХржЗрж╕рж╛ржерзЗ, рж╕рзЗржЗ socket ржмрж╛ file descriptor ржХрзЗ epoll instance-ржП register ржХрж░рзЗ рж░рж╛ржЦрзЗ (<code>epoll_ctl</code> ржжрж┐рзЯрзЗ)ред</li>
</ul>
</li>
</ul>
<p><strong>3. epoll_wait ржХрзА ржХрж░рзЗ?</strong></p>
<ul>
<li>ржЖрж▓рж╛ржжрж╛ Netpoller Thread рж╕ржмрж╕ржорзЯ epoll_wait syscall ржЪрж╛рж▓рж┐рзЯрзЗ ржШрзБржорж┐рзЯрзЗ ржерж╛ржХрзЗред</li>
<li>ржпржЦржи kernel detect ржХрж░рзЗ ржпрзЗ socket/data ready, рждржЦржи рж╕рзЗржЗ Netpoller Thread ржХрзЗ wake ржХрж░рзЗ ржжрж┐рзЯрзЗ data ржжрзЗрзЯред</li>
<li>ржПрж░ржкрж░ Netpoller ржЬрж╛ржирж╛рзЯ ржпрзЗ fd readyред</li>
</ul>
<p><strong>4. Go Runtime ржкрзБржирж░рж╛рзЯ goroutine ржЪрж╛рж▓рзБ ржХрж░рзЗ</strong></p>
<ul>
<li>Go runtime ржмрзБржЭрзЗ ржпрж╛рзЯ ржпрзЗ ржпрзЗ goroutine file/socket read ржХрж░рждрзЗ ржЪрзЗрзЯрзЗржЫрж┐рж▓ рждрж╛рж░ data ржПрж╕рзЗ ржЧрзЗржЫрзЗред</li>
<li>рждрж╛ржХрзЗ ржЖржмрж╛рж░ runnable ржХрж░рзЗ ржжрзЗрзЯ, ржПржмржВ data ржкрзЬрж╛ рж╢рзБрж░рзБ рж╣рзЯред</li>
</ul>
<h3 id="-setting-up-garbage-collector-gc"><a class="header" href="#-setting-up-garbage-collector-gc">тЪЩя╕П Setting Up Garbage Collector (GC)</a></h3>
<ul>
<li>Go runtime GC ржЪрж╛рж▓рж╛ржирзЛрж░ ржЬржирзНржп ржЖрж▓рж╛ржжрж╛ OS thread ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ, ржпрж╛рждрзЗ ржкрзНрж░рзЛржЧрзНрж░рж╛ржорзЗрж░ ржорзВрж▓ ржХрж╛ржЬ ржмрж┐ржШрзНржи ржирж╛ ржШржЯрзЗ</li>
<li>thread ржЧрзБрж▓рзЛ background-ржП silently ржХрж╛ржЬ ржХрж░рзЗ memory clean рж░рж╛ржЦрзЗ</li>
<li>Go Runtime ржкрзБрж░рзЛржкрзБрж░рж┐ GC thread control ржХрж░рзЗ</li>
</ul>
<h3 id="-go-scheduling"><a class="header" href="#-go-scheduling">ЁЯза Go Scheduling</a></h3>
<p>Go runtime M:P:G model scheduling follow ржХрж░рзЗ, ржпрзЗржЦрж╛ржирзЗ</p>
<ul>
<li>M = Machine (OS-level Thread) тАФ ржпрзЗржЯрж╛ ржмрж╛рж╕рзНрждржмрзЗ CPU-рждрзЗ ржХрж╛ржЬ ржЪрж╛рж▓рж╛рзЯред</li>
<li>P = Processor (Logical Processor) тАФ ржПржЯрж┐ goroutine run ржХрж░рж╛рж░ ржЬржирзНржп ржкрзНрж░рзЯрзЛржЬржирзАрзЯ execution context ржзрж░рзЗ рж░рж╛ржЦрзЗ, ржпрзЗржоржи: local run queue, stack, scheduler info ржЗрждрзНржпрж╛ржжрж┐ред</li>
<li>G = Goroutine тАФ ржЖржорж░рж╛ ржпрзЗрж╕ржм Go function/logic concurrently ржЪрж╛рж▓рж╛ржЗ, ржПржЧрзБрж▓рзЛржХрзЗ Go runtime тАЬgoroutineтАЭ ржирж╛ржорзЗ ржЪрж╛рж▓рж╛рзЯред</li>
</ul>
<h4 id="-go-scheduler-initialization"><a class="header" href="#-go-scheduler-initialization">ЁЯПЧя╕П Go Scheduler Initialization</a></h4>
<p><strong>M (Machine, ржмрж╛ OS Thread) рждрзИрж░рж┐</strong></p>
<p>Go runtime рж╢рзБрж░рзБрждрзЗржЗ exactly vCPU рж╕ржВржЦрзНржпржХ machine thread (M) рждрзИрж░рж┐рж░ ржЬржирзНржп OS ржХрзЗ request ржХрж░рзЗред</p>
<ul>
<li>1 core тЖТ 2 vCPU тЖТ 2 M</li>
<li>2 core тЖТ 4 vCPU тЖТ 4 M</li>
</ul>
<p><strong>P (Logical Processor) рждрзИрж░рж┐</strong></p>
<p>ЁЯФ╣ Go runtime M рж╕ржВржЦрзНржпржХ "Logical Processor" рждрзИрж░рж┐ ржХрж░рзЗ, ржпрж╛ржХрзЗ P ржмрж▓рж╛ рж╣рзЯ</p>
<ul>
<li>4 M : 4 P</li>
</ul>
<p>ЁЯФ╣ ржПржЗ P ржЧрзБрж▓рзЛ ржжрзЗржЦрждрзЗ ржЕржирзЗржХржЯрж╛ Virtual CPU (vCPU) ржПрж░ ржорждрзЛ</p>
<p>ЁЯФ╣ ржХрж┐ржирзНрждрзБ ржПржЧрзБрж▓рзЛ hardware vCPU ржирж╛, ржмрж░ржВ Go runtime ржПрж░ internal scheduling unit</p>
<p><strong>G (Goroutine) рждрзИрж░рж┐</strong></p>
<p>ЁЯФ╕ Go runtime-ржПрж░ рж╕ржмржЪрзЗрзЯрзЗ lightweight execution unit рж╣ржЪрзНржЫрзЗ Goroutine (G)</p>
<p>ЁЯФ╕ ржкрзНрж░рждрж┐ржЯрж┐ <code>go someFunction()</code> ржХрж▓ ржХрж░рж▓рзЗ ржирждрзБржи ржПржХржЯрж╛ goroutine рждрзИрж░рж┐ рж╣рзЯ</p>
<h3 id="-go-scheduler-1m--1p--2g-diagram"><a class="header" href="#-go-scheduler-1m--1p--2g-diagram">ЁЯзй Go Scheduler: 1M : 1P : 2G Diagram</a></h3>
<p>ржоржирзЗ ржХрж░рж┐, 1M:1P:2G тАФ ржПржмржВ ржоржирзЗ рж╣ржЪрзНржЫрзЗ 1P ржжрзБржЗржЯрж╛ goroutine ржПржХрж╕рж╛ржерзЗ ржЪрж╛рж▓рж╛ржЪрзНржЫрзЗ, ржЖрж░ 1M ржЪрж╛рж▓рж╛ржЪрзНржЫрзЗ рж╕рзЗржЗ 1P-ржХрзЗ</p>
<pre><code class="language-markdown">                        тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
                        тФВ   Machine M  тФВ  тЖР OS Thread (Executes G via P)
                        тФФтФАтФАтФАтФАтФАтФАтФмтФАтФАтФАтФАтФАтФАтФАтФШ
                               тФВ
                               тЦ╝
                        тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
                        тФВ Logical P    тФВ  тЖР Holds G run queue
                        тФФтФАтФАтФАтФАтФАтФАтФмтФАтФАтФАтФАтФАтФАтФАтФШ
                               тФВ
                тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФ┤тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
                тЦ╝                             тЦ╝
        тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР             тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
        тФВ Goroutine G1 тФВ             тФВ Goroutine G2 тФВ
        тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ             тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
</code></pre>
<h3 id="-1-core-scenario-in-go-scheduler"><a class="header" href="#-1-core-scenario-in-go-scheduler">ЁЯза 1 Core Scenario in Go Scheduler</a></h3>
<h4 id="-initialization-phase"><a class="header" href="#-initialization-phase">тЬЕ Initialization Phase:</a></h4>
<ul>
<li>OS ржерзЗржХрзЗ ржкрж╛ржУржпрж╝рж╛ ржпрж╛рзЯ тЖТ 1 Core тЗТ 2 vCPU</li>
<li>рждрж╛ржЗ Go runtime рждрзИрж░рж┐ ржХрж░рзЗ:
<ul>
<li>2 Machine Thread (M)</li>
<li>2 Logical Processor (P)</li>
</ul>
</li>
</ul>
<pre><code class="language-markdown">          ЁЯза Physical Core (1)
                тФВ
        тХФтХРтХРтХРтХРтХРтХРтХРтХзтХРтХРтХРтХРтХРтХРтХРтХРтХЧ
        тЦ╝                тЦ╝
     M1 (Thread)      M2 (Thread)
       тФВ                 тФВ
       тЦ╝                 тЦ╝
    тФМтФАтФАтФАтФАтФАтФР           тФМтФАтФАтФАтФАтФАтФР
    тФВ  P1 тФВ           тФВ  P2 тФВ
    тФФтФАтФмтФАтФАтФАтФШ           тФФтФАтФмтФАтФАтФАтФШ
      тФВ                 тФВ

тФМтФАтФАтФАтЦ╝тФАтФАтФАтФР тФМтФАтФАтФАтЦ╝тФАтФАтФАтФР
тФВ G1,G2 тФВ тФВ G3,G4 тФВ тЖР Each P has its G queue
тФФтФАтФАтФАтФАтФАтФАтФАтФШ тФФтФАтФАтФАтФАтФАтФАтФАтФШ
</code></pre>
<h3 id="-run-queue"><a class="header" href="#-run-queue">ЁЯзк Run Queue</a></h3>
<p>Go ржПрж░ scheduler-ржП рзи ржзрж░ржирзЗрж░ run queue ржерж╛ржХрзЗ</p>
<h3 id="-рзз-local-run-queue-per-p"><a class="header" href="#-рзз-local-run-queue-per-p">ЁЯз╡ рзз. Local Run Queue (per P)</a></h3>
<p>ржкрзНрж░рждрж┐ржЯрж┐ Logical Processor (P) ржПрж░ ржирж┐ржЬрж╕рзНржм ржПржХржЯрж┐ Run Queue ржерж╛ржХрзЗ, ржпрзЗржЦрж╛ржирзЗ goroutine (G) ржЧрзБрж▓рзЛ рж░рж╛ржЦрж╛ рж╣рзЯред</p>
<h4 id="-ржХрзАржнрж╛ржмрзЗ-ржХрж╛ржЬ-ржХрж░рзЗ"><a class="header" href="#-ржХрзАржнрж╛ржмрзЗ-ржХрж╛ржЬ-ржХрж░рзЗ">ЁЯзй ржХрзАржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ:</a></h4>
<ul>
<li>ржкрзНрж░рждрж┐ржЯрж┐ P ржПржХржЯрж┐ fixed-size circular run queue ржорзЗржЗржиржЯрзЗржЗржи ржХрж░рзЗ ржпрж╛ ring ржПрж░ ржорждрзЛ</li>
<li>ржкрзНрж░рждрж┐ржЯрж┐ Local Run Queue ржПрж░ slot 256 тЖТ 256 goroutine</li>
<li>ржкрзНрж░рждрж┐ржЯрж┐ P рждрж╛рж░ queue ржПрж░ G ржЧрзБрж▓рзЛржХрзЗ FIFO ржнрж┐рждрзНрждрж┐рждрзЗ ржЪрж╛рж▓рж╛рзЯ (First-In-First-Out).</li>
<li>ржпрзЗржЗ P ржмрж░рзНрждржорж╛ржирзЗ M ржжрзНржмрж╛рж░рж╛ ржЪрж╛рж▓рж┐ржд рж╣ржЪрзНржЫрзЗ, рж╕рзЗржЗ P рждрж╛рж░ queue ржерзЗржХрзЗ goroutine G ржирж┐рзЯрзЗ ржЪрж╛рж▓рж╛рзЯред</li>
<li>ржпржжрж┐ ржХрзЛржи G ржмрзНрж▓ржХ ржХрж░рзЗ (I/O, sleep etc), рждрж╛рж╣рж▓рзЗ P ржЖржмрж╛рж░ queue ржерзЗржХрзЗ ржирждрзБржи G ржЪрж╛рж▓рж╛рзЯред</li>
<li>ржпржжрж┐ P ржПрж░ queue ржЦрж╛рж▓рж┐ рж╣рзЯрзЗ ржпрж╛рзЯ, рждрж╛рж╣рж▓рзЗ:
<ul>
<li>рж╕рзЗ <code>work stealing</code> ржХрж░рзЗ тАФ ржЕржирзНржп P ржПрж░ queue ржерзЗржХрзЗ G ржЪрзБрж░рж┐ ржХрж░рзЗ ржирзЗрзЯред</li>
</ul>
</li>
</ul>
<h3 id="-рзи-global-run-queue"><a class="header" href="#-рзи-global-run-queue">ЁЯМН рзи. Global Run Queue</a></h3>
<p>ржпрзЗрж╕ржм goroutine-ржХрзЗ ржХрзЛржирзЛ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ P-рждрзЗ assign ржХрж░рж╛ ржпрж╛рзЯ ржирж╛, рж╕рзЗржЧрзБрж▓рзЛ Global Run Queue-рждрзЗ рж░рж╛ржЦрж╛ рж╣рзЯред</p>
<ul>
<li>System-wide queue, рж╕ржм P access ржХрж░рждрзЗ ржкрж╛рж░рзЗред</li>
<li>Locking ржжрж░ржХрж╛рж░ ржкрзЬрзЗ, рждрж╛ржЗ ржПржХржЯрзБ ржзрзАрж░ред</li>
<li>ржпржЦржи ржХрзЛржирзЛ P-рж░ local queue ржЦрж╛рж▓рж┐ рж╣рзЯ, рждржЦржи рж╕рзЗ Global queue ржерзЗржХрзЗ ржХрж╛ржЬ ржирзЗрзЯред</li>
</ul>
<blockquote>
<p>ЁЯФР Locking рж╣ржЪрзНржЫрзЗ ржПржоржи ржПржХржЯрж╛ ржмрзНржпржмрж╕рзНржерж╛, ржпрзЗржЯрж╛ ржжрж┐рзЯрзЗ ржПржХржЗ рж╕ржорзЯ ржПржХрж╛ржзрж┐ржХ goroutine ржпрзЗржи ржПржХрж╕рж╛ржерзЗ ржПржХржЗ ржЬрж┐ржирж┐рж╕рзЗ рж╣рж╛ржд ржирж╛ ржжрж┐рждрзЗ ржкрж╛рж░рзЗ, рж╕рзЗржЯрж╛ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рж╛ рж╣рзЯред</p>
</blockquote>
<ul>
<li>
<p>newly created goroutines ржпрзЗ local run queue рждрзЗ ржЬрж╛рзЯржЧрж╛ ржкрж╛ржмрзЗ ржмрж╕рзЗ ржпрж╛ржмрзЗред</p>
</li>
<li>
<p>logical processor free ржерж╛ржХрж▓рзЗ local run queue ржерзЗржХрзЗ goroutine ржирж┐рзЯрзЗ execute ржХрж░рждрзЗ ржерж╛ржХрзЗред</p>
</li>
<li>
<p>ржкрзНрж░рждрж┐ржЯрж┐ local run queue ржПржХржЯрж┐ ржХрж░рзЗ goroutine execute ржХрж░рзЗ ржПржмржВ slot ржЧрзБрж▓рзЛрждрзЗ 256 ржЯрж┐ ржХрж░рзЗ goroutines ржерж╛ржХрж▓рзЗ newly created goroutines ржЧрзБрж▓рзЛ global run queue рждрзЗ ржЧрж┐рзЯрзЗ ржмрж╕рзЗ</p>
</li>
<li>
<p>ржпржжрж┐ local run queue ржЦрж╛рж▓рж┐ рж╣рзЯрзЗ ржпрж╛рзЯ, рждрж╛рж╣рж▓рзЗ рж╕рзЗ ржЕржирзНржп P ржПрж░ queue ржерзЗржХрзЗ half goroutines ржирж┐рзЯрзЗ ржирзЗрзЯ (this is called <code>Work Stealing</code>).</p>
</li>
<li>
<p>ржХрзЛржи processor free рж╣рж▓рзЗ ржПржмржВ ржПрж░ local run queue рждрзЗ ржХрзЛржи goroutine ржирж╛ ржерж╛ржХрж▓рзЗ, ржПржмржВ ржЕржирзНржп logical processor ржПрж░ local run queue рждрзЗржУ goroutines ржирж╛ ржерж╛ржХрж▓рзЗ (ржПржХрзНрж╖рзЗрждрзНрж░рзЗ work stealing ржХрж░рждрзЗ ржкрж╛рж░рзЗржирж╛) ржПржЯрж┐ global run queue ржерзЗржХрзЗ goroutines ржирж┐рзЯрзЗ execute ржХрж░рзЗ</p>
</li>
</ul>
<h3 id="-execution-of-maingo"><a class="header" href="#-execution-of-maingo">ЁЯФ╣ Execution of <code>main.go</code></a></h3>
<pre><code class="language-go">package main

import (
	"fmt"
	"net/http"
)

func handler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintln(w, "hello world")
}

func aboutHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "About page")
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", handler)
	mux.HandleFunc("/about", aboutHandler)

	fmt.Println("Server running on :8080")
	err := http.ListenAndServe(":8080", mux)
	if err != nil {
		fmt.Println("Error starting server", err)
	}
}
</code></pre>
<pre><code class="language-bash">go build main.go
./main
</code></pre>
<h4 id="-go-program-memory-layout"><a class="header" href="#-go-program-memory-layout">ЁЯУж Go Program Memory Layout</a></h4>
<pre><code class="language-markdown">                        +----------------------------+
                        |        Code Segment        |
                        |----------------------------|
                        | - func handler             |
                        | - func aboutHandler        |
                        | - func main                |
                        | - imported fmt, net/http   |
                        +----------------------------+

                        +----------------------------+
                        |       Data Segment         |
                        |----------------------------|
                        | - Static/global data       |
                        | - Function/method metadata |
                        | - String constants         |
                        |   e.g., "hello world"      |
                        |         "About page"       |
                        |         ":8080"            |
                        +----------------------------+

                        +----------------------------+
                        |           Heap             |
                        |----------------------------|
                        | - Dynamically allocated    |
                        |   memory during runtime    |
                        | - mux := http.NewServeMux()|
                        | - Each request's data      |
                        | - Goroutines' data         |
                        +----------------------------+

                        +----------------------------+
                        |           Stack            |
                        |----------------------------|
                        | - Go Runtime Code          |
                        |                            |
                        +----------------------------+
</code></pre>
<h3 id="-go-http-server-execution"><a class="header" href="#-go-http-server-execution">ЁЯМА Go HTTP Server Execution</a></h3>
<p><strong>ЁЯФ╣ рзз. Go рж░рж╛ржиржЯрж╛ржЗржо ржЪрж╛рж▓рзБ рж╣ржУржпрж╝рж╛рж░ рж╢рзБрж░рзБрждрзЗ:</strong></p>
<ul>
<li>Go ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржЪрж╛рж▓рзБ рж╣рж▓рзЗ:
<ul>
<li>ржкрзНрж░ржержорзЗ <strong>init()</strong> ржлрж╛ржВрж╢ржиржЧрзБрж▓рзЛ (ржпржжрж┐ ржерж╛ржХрзЗ) execute рж╣ржпрж╝ред</li>
<li>ржПрж░ржкрж░ memory layout ржЕржирзБржпрж╛ржпрж╝рзА code segment, data segment, ржЗрждрзНржпрж╛ржжрж┐ рж╕рзЗржЯржЖржк рж╣ржпрж╝ред</li>
</ul>
</li>
</ul>
<p><strong>ЁЯФ╣ рзи. Main Thread &amp; Stack Setup</strong></p>
<ul>
<li>Go runtime ржПржХржЯрж╛ main OS thread рждрзИрж░рж┐ ржХрж░рзЗред</li>
<li>ржПржЗ ржерзНрж░рзЗржбрзЗрж░ ржЬржирзНржп ржПржХржЯрж╛ main stack allocate ржХрж░рзЗред</li>
<li>ржПржЗ stack-ржП runtime code ржУ ржЕржирзНржпрж╛ржирзНржп execution ржЪрж▓ржмрзЗред</li>
</ul>
<p><strong>ЁЯФ╣ рзй. Main Goroutine рждрзИрж░рж┐</strong></p>
<ul>
<li>Go automatically ржПржХржЯрж╛ main goroutine рждрзИрж░рж┐ ржХрж░рзЗред</li>
<li>ржПрж░ initial stack size рж╣рзЯ 2KB (heap-ржП allocate ржХрж░рж╛ рж╣рзЯ)ред</li>
<li>ржПржЗ goroutine ржерж╛ржХржмрзЗ local run queue-рждрзЗред</li>
</ul>
<p><strong>ЁЯФ╣ рзк. Scheduler ржПржмржВ Processor</strong></p>
<ul>
<li>Go runtime-ржП ржЖржЫрзЗ:
<ul>
<li>M (Machine = Thread)</li>
<li>P (Processor = Logical executor)</li>
<li>G (Goroutine)</li>
</ul>
</li>
<li>ржпржЦржи Go start рж╣рзЯ, main goroutine local run queue рждрзЗ enqueue рж╣рзЯред</li>
<li>ржПржХржЯрж┐ P (logical processor) active ржерж╛ржХрзЗ тАФ рж╢рзБржзрзБ рж╕рзЗ ржХрж╛ржЬ ржХрж░рзЗ ржХрж╛рж░ржг ржПржЗ ржорзБрж╣рзВрж░рзНрждрзЗ ржПржХржорж╛рждрзНрж░ main goroutine-ржЯрж╛ржЗ activeред</li>
<li>ржЕржирзНржп P ржЧрзБрж▓рзЛ sleep ржХрж░рзЗ ржерж╛ржХржмрзЗ ржпржжрж┐ ржЖрж░ ржХрзЛржирзЛ goroutine ржирж╛ ржерж╛ржХрзЗред</li>
</ul>
<p><strong>ЁЯФ╣ рзл. main() Function Execution рж╢рзБрж░рзБ</strong></p>
<ul>
<li>Main goroutine-ржПрж░ ржнрж┐рждрж░:
<ul>
<li>main() function-ржПрж░ ржЬржирзНржп ржПржХржЯрж╛ stack frame рждрзИрж░рж┐ рж╣рзЯред</li>
<li>рждрж╛рж░ржкрж░ main() ржлрж╛ржВрж╢ржирзЗрж░ ржнрж┐рждрж░рзЗрж░ ржХрзЛржб execute рж╣рждрзЗ ржерж╛ржХрзЗред</li>
</ul>
</li>
</ul>
<p><strong>ЁЯФ╣ рзм. Router Creation</strong></p>
<ul>
<li>http.NewServeMux() ржХрж▓ ржХрж░рж╛ рж╣рзЯ:
<ul>
<li>ржПржЯрж┐ ржПржХржЯрж┐ ServeMux object рждрзИрж░рж┐ ржХрж░рзЗред</li>
<li>ржПржЗ object ржЯрж┐ main goroutine-ржПрж░ stack frame ржП ржерж╛ржХрзЗред</li>
</ul>
</li>
</ul>
<p><strong>ЁЯФ╣ рзн. Route Register</strong></p>
<ul>
<li>mux.Handle("/", handler):
<ul>
<li>Mux object-ржПрж░ ржнрж┐рждрж░рзЗ route pattern ржУ handler function register рж╣рзЯред</li>
<li>ржПржЧрзБрж▓рзЛ map ржЖржХрж╛рж░рзЗ ServeMux struct-ржП store рж╣рзЯред</li>
</ul>
</li>
</ul>
<p><strong>ЁЯФ╣ рзо. Server Start</strong></p>
<ul>
<li>http.ListenAndServe(":8080", mux):
<ul>
<li>ржПржЯрж╛ main goroutine ржерзЗржХрзЗ call рж╣рзЯред</li>
<li>ржПрж░ ржЬржирзНржп ржПржХржЯрж┐ ржирждрзБржи stack frame рждрзИрж░рж┐ рж╣рзЯред</li>
</ul>
</li>
</ul>
<p><strong>ЁЯФ╣ рзп. Internal serve() Call</strong></p>
<ul>
<li>ListenAndServe() ржПрж░ ржнрж┐рждрж░:
<ul>
<li>srv.Serve(l net.Listener) function call рж╣рзЯред</li>
<li>ржПрж░ ржЬржирзНржп ржЖрж░рзЗржХржЯрж┐ stack frame рждрзИрж░рж┐ рж╣рзЯред</li>
</ul>
</li>
</ul>
<p><strong>ЁЯФВ ЁЯФБ рззрзж. Server-ржПрж░ Infinite Loop</strong></p>
<ul>
<li>Serve() function-ржПрж░ ржнрж┐рждрж░рзЗ ржерж╛ржХрзЗ ржПржХржЯрж┐ infinite for loop:
<ul>
<li>ржпрзЗржЯрж╛ ржкрзНрж░рждрж┐ iteration-ржП ржХрж░рзЗ:
<ul>
<li>Accept() ржХрж░рзЗ ржирждрзБржи connectionред</li>
<li>ржкрзНрж░рждрж┐ржЯрж┐ connection ржПрж░ ржЬржирзНржп ржирждрзБржи goroutine рждрзИрж░рж┐ ржХрж░рзЗред</li>
<li>рж╕рзЗржЗ goroutine handle ржХрж░рзЗ HTTP request-responseред</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-markdown">Program Start
тФВ
тФЬтФА&gt; Execute init()
тФЬтФА&gt; Setup code/data segment
тФЬтФА&gt; Create main thread + main stack
тФЬтФА&gt; Create main goroutine (2KB heap stack)
тФВ
тФФтФА&gt; main goroutine enqueued тЖТ local run queue тЖТ executed by P

Main Goroutine:
тФВ
тФЬтФА&gt; main() stack frame created
тФВ тФЬтФА&gt; mux := http.NewServeMux()
тФВ тФЬтФА&gt; mux.Handle("/", handler)
тФВ тФФтФА&gt; http.ListenAndServe(":8080", mux)
тФВ тФФтФА&gt; srv.Serve(listener)
тФВ тФФтФА&gt; infinite for loop
тФВ тФФтФА&gt; accept conn тЖТ new goroutine тЖТ handle request
</code></pre>
<pre><code class="language-go">for {
    rw, err := l.Accept()
    go c.serve(connCtx)
}
</code></pre>
<h3 id="-go-http-server-accepts-connection-and-handles-it"><a class="header" href="#-go-http-server-accepts-connection-and-handles-it">ЁЯза Go HTTP Server accepts connection and handles it</a></h3>
<p><strong>ЁЯФ╣ рзз. l.Accept() ржХрж▓ рж╣рзЯ</strong></p>
<ul>
<li>ржПржЯрж┐ ржПржХржЯрж┐ network socket accept callред</li>
<li>ржПрж░ ржЬржирзНржп ржПржХржЯрж┐ ржирждрзБржи stack frame рждрзИрж░рж┐ рж╣ржпрж╝ред</li>
<li>ржПрж░ ржХрж╛ржЬ рж╣ржЪрзНржЫрзЗ:
<ul>
<li>ржирждрзБржи ржХрзЗржЙ connect ржХрж░рждрзЗ ржЪрж╛ржЗрж▓рзЗ, рждрж╛рж░ рж╕рж╛ржерзЗ communication рж╢рзБрж░рзБ ржХрж░рж╛ред</li>
</ul>
</li>
</ul>
<p><strong>ЁЯФ╣ рзи. Accept() ржХрзА ржХрж░рзЗ?</strong></p>
<ul>
<li>main goroutine тЖТ Accept() call ржХрж░рзЗ тЖТ ржПржЯрж┐ Go runtime ржХрзЗ ржмрж▓рзЗ:
<ul>
<li>тАЬржЖржорж╛ржХрзЗ ржПржХржЯрж╛ socket ржжрж╛ржУ, ржпрж╛рждрзЗ ржЖржорж┐ ржирждрзБржи connection handle ржХрж░рждрзЗ ржкрж╛рж░рж┐редтАЭ</li>
<li>Go runtime рждржЦржи ржжрзЗржЦрзЗ, тАЬржЖржорж╛рж░ ржХрж╛ржЫрзЗ ржХрж┐ socket ржЖржЧрзЗ ржерзЗржХрзЗржЗ ready ржЖржЫрзЗ?тАЭ</li>
</ul>
</li>
</ul>
<p><strong>ЁЯФ╣ рзй. Socket ржирж╛ ржерж╛ржХрж▓рзЗ ржХрзА рж╣рзЯ?</strong></p>
<ul>
<li>ржпржжрж┐ socket ржирж╛ ржерж╛ржХрзЗ:
<ul>
<li>Go runtime тЖТ epoll_ctl() call ржХрж░рзЗ тЖТ kernel ржХрзЗ ржмрж▓рзЗ:
<ul>
<li>тАЬрждрзБржорж┐ ржПржХржЯрж╛ socket рждрзИрж░рж┐ ржХрж░рзЛ ржПржмржВ future-ржП ready рж╣рж▓рзЗ ржЖржорж╛ржХрзЗ ржЬрж╛ржирж┐ржУредтАЭ</li>
</ul>
</li>
</ul>
</li>
<li>ржПржЗ ржХрж╛ржЬржЯрж╛ Go-ржПрж░ netpoll library ржПрж░ ржорж╛ржзрзНржпржорзЗ ржХрж░рж╛ рж╣рзЯред</li>
</ul>
<p><strong>ЁЯФ╣ рзк. epoll_ctl тЖТ kernel</strong></p>
<ul>
<li>epoll_ctl() ржПржХржЯрж╛ asynchronous system call:
<ul>
<li>ржорж╛ржирзЗ ржПржЯрж╛ main goroutine ржХрзЗ block ржХрж░рзЗ ржирж╛ред</li>
<li>Go runtime meanwhile ржЕржирзНржпрж╛ржирзНржп ржХрж╛ржЬ ржЪрж╛рж▓рж╛рждрзЗ ржкрж╛рж░рзЗред</li>
</ul>
</li>
</ul>
<p><strong>ЁЯФ╣ рзл. Linux kernel ржХрзА ржХрж░рзЗ?</strong></p>
<ul>
<li>Linux-ржП рж╕ржмржХрж┐ржЫрзБ file рж╣рж┐рж╕рзЗржмрзЗ treat ржХрж░рж╛ рж╣ржпрж╝ (socket, file, device тАФ рж╕ржмржХрж┐ржЫрзБ)ред</li>
<li>Kernel ржПржХржЯрж┐ socket рждрзИрж░рж┐ ржХрж░рзЗ тАФ ржПржЯрж╛ ржПржХ ржкрзНрж░рж╛ржирзНржд ржпрж╛ ржжрж┐рзЯрзЗ data ржкрж╛ржарж╛ржирзЛ ржУ ржЧрзНрж░рж╣ржг ржХрж░рж╛ ржпрж╛ржпрж╝ (like pipe)ред</li>
<li>ржПржЗ socket-ржПрж░ ржЬржирзНржп kernel ржПржХржЯрж┐ file descriptor (FD) ржжрзЗржпрж╝ред
<ul>
<li>ржпрзЗржоржи, ржзрж░рзЛ FD = 5</li>
</ul>
</li>
</ul>
<p><strong>ЁЯФ╣ рзм. Main Thread Sleep ржХрж░рзЗ</strong></p>
<ul>
<li>main goroutine рждржЦржи sleep ржХрж░рзЗ ржерж╛ржХрзЗ, ржХрж╛рж░ржг рж╕рзЗ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржЫрзЗ ржирждрзБржи socket connection-ржПрж░ ржЬржирзНржпред</li>
<li>ржХрж┐ржирзНрждрзБ ржПржЗ рж╕ржорзЯрзЗржУ Go runtime ржмржирзНржз рж╣ржпрж╝ ржирж╛ тАФ ржЕржирзНржпрж╛ржирзНржп goroutine ржЧрзБрж▓рзЛ ржЪрж╛рж▓рзБ ржерж╛ржХрждрзЗ ржкрж╛рж░рзЗред</li>
</ul>
<p><strong>ЁЯФ╣ рзн. New Connection ржПрж▓рзЗ</strong></p>
<ul>
<li>ржХрзЗржЙ ржпржЦржи connect ржХрж░рзЗ:
<ul>
<li>Kernel ржмрж▓рзЗ: тАЬржПржЗ socket (FD 5) now ready!тАЭ</li>
<li>Go runtime ржПрж░ netpoller ржЬрзЗржЧрзЗ ржЙржарзЗ (via epoll_wait) ржПржмржВ рж╕рзЗржЗ connection ржЧрзНрж░рж╣ржг ржХрж░рзЗред</li>
</ul>
</li>
</ul>
<p><strong>ЁЯФ╣ рзо. New goroutine handle ржХрж░рзЗ</strong></p>
<ul>
<li>рждрж╛рж░ржкрж░ Go runtime:
<ul>
<li><code>go c.serve(connCtx)</code> ржХрж▓ ржХрж░рзЗ</li>
<li>ржирждрзБржи goroutine рждрзИрж░рж┐ рж╣ржпрж╝ тЖТ ржПржЯрж┐ рж╕рзЗржЗ connection ржПрж░ request/response handle ржХрж░рзЗ</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Step</th><th>Description</th></tr></thead><tbody>
<tr><td>1я╕ПтГг</td><td><code>Accept()</code> call тЖТ ржирждрзБржи connection ржЪрж╛ржЗ</td></tr>
<tr><td>2я╕ПтГг</td><td>Go runtime checks тЖТ socket available?</td></tr>
<tr><td>3я╕ПтГг</td><td>ржирж╛ ржерж╛ржХрж▓рзЗ тЖТ <code>epoll_ctl()</code> тЖТ kernel socket рждрзИрж░рж┐</td></tr>
<tr><td>4я╕ПтГг</td><td>Kernel тЖТ socket рждрзИрж░рж┐ ржХрж░рзЗ (e.g. FD = 5)</td></tr>
<tr><td>5я╕ПтГг</td><td>main goroutine sleeps тЖТ non-blocking epoll</td></tr>
<tr><td>6я╕ПтГг</td><td>New connection ржПрж▓рзЗ тЖТ <code>epoll_wait</code> wakes Go runtime</td></tr>
<tr><td>7я╕ПтГг</td><td><code>go c.serve()</code> тЖТ new goroutine handles request</td></tr>
</tbody></table>
</div>
<h3 id="-ржпржЦржи-ржПржХржЯрж┐-http-request-ржХрж░рж╛-рж╣ржп--ржнрж┐рждрж░рзЗрж░-ржЬржЧрзО-go-http-server--os--nic--kernel"><a class="header" href="#-ржпржЦржи-ржПржХржЯрж┐-http-request-ржХрж░рж╛-рж╣ржп--ржнрж┐рждрж░рзЗрж░-ржЬржЧрзО-go-http-server--os--nic--kernel">ЁЯМР ржпржЦржи ржПржХржЯрж┐ HTTP Request ржХрж░рж╛ рж╣ржпрж╝ тАФ ржнрж┐рждрж░рзЗрж░ ржЬржЧрзО (Go HTTP Server + OS + NIC + Kernel)</a></h3>
<p><strong>ЁЯФ╣ рзз. ржмрзНрж░рж╛ржЙржЬрж╛рж░рзЗ ржЖржорж░рж╛ URL ржжрж┐ржЗ (ржпрзЗржоржи: http://localhost:8080/)</strong></p>
<ul>
<li>ржПржЗ request ржкрзНрж░ржержорзЗ ржпрж╛рзЯ router тЖТ router тЖТ server router ржПрж░ ржжрж┐ржХрзЗ (DNS resolve ржзрж░рзЗ ржирзЗржУржпрж╝рж╛ рж╣ржпрж╝рзЗржЫрзЗ)ред</li>
</ul>
<p><strong>ЁЯФ╣ рзи. Server ржПрж░ Network Interface</strong></p>
<ul>
<li>Server-side ржПрж░ Network Interface Controller (NIC) тАФ рж╣рждрзЗ ржкрж╛рж░рзЗ Ethernet Cable ржмрж╛ Wi-Fi Adapter тАФ ржПржЗ request ржзрж░рзЗред</li>
<li>ржПржЗ NIC data ржЧрзБрж▓рзЛ рж▓рзЗржЦрзЗ рждрж╛рж░ NIC Receive Buffer (RAM ржПрж░ ржПржХржЯрж╛ ржЕржВрж╢) ржПред</li>
</ul>
<p>**ЁЯФ╣ рзй. NIC Interrupt **</p>
<ul>
<li>ржпрзЗржЗ ржорзБрж╣рзВрж░рзНрждрзЗ NIC data ржкрж╛ржпрж╝, рж╕рзЗ рждржЦржи Interrupt Signal ржкрж╛ржарж╛ржпрж╝ Kernel ржХрзЗред</li>
<li>Kernel рждржЦржи ржПрж╕рзЗ NIC Receive Buffer ржерзЗржХрзЗ data ржкржбрж╝рзЗред</li>
</ul>
<p><strong>ЁЯФ╣ рзк. Kernel тЖТ Socket Receive Buffer</strong></p>
<ul>
<li>Kernel data ржХрзЗ write ржХрж░рзЗ Socket Receive Buffer ржП (ржпрзЗржЯрж╛ File Descriptor fd 5 ржПрж░ рж╕рж╛ржерзЗ ржпрзБржХрзНржд)ред</li>
</ul>
<p><strong>ЁЯФ╣ рзл. Kernel тЖТ fd 5 Ready</strong></p>
<ul>
<li>ржПрж░ржкрж░ Kernel fd 5 ржХрзЗ ready for read рж╣рж┐рж╕рзЗржмрзЗ mark ржХрж░рзЗред</li>
</ul>
<p><strong>ЁЯФ╣ рзм. epoll_wait() тЖТ Wake Up</strong></p>
<ul>
<li>ржпрзЗрж╣рзЗрждрзБ Go runtime epoll_wait() ржжрж┐ржпрж╝рзЗ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржЫрж┐рж▓, kernel ржПржЦржи:
<ul>
<li>рж╕рзЗржЗ sleeping epoll_wait() thread ржХрзЗ wake ржХрж░рзЗред</li>
<li>ржПржмржВ ржмрж▓рзЗ: тАЬfd 5 ржПржЦржи readyредтАЭ</li>
</ul>
</li>
</ul>
<p><strong>ЁЯФ╣ рзн. epoll_wait тЖТ Go Runtime</strong></p>
<ul>
<li>epoll_wait() ржПржЗ fd 5 ржХрзЗ Go runtime ржПрж░ ржХрж╛ржЫрзЗ ржкрж╛ржарж╛ржпрж╝ред</li>
</ul>
<p><strong>ЁЯФ╣ рзо. Go Runtime тЖТ Sleeping Goroutines</strong></p>
<ul>
<li>Go runtime ржжрзЗржЦрзЗ, тАЬржПржЗ fd 5 ржПрж░ ржЬржирзНржп ржХрзЛржирзЛ goroutine ржЖржЧрзЗ ржерзЗржХрзЗ ржШрзБржорж┐ржпрж╝рзЗ ржЫрж┐рж▓рзЛ?тАЭ</li>
<li>ржпржжрж┐ ржерж╛ржХрзЗ, рждржмрзЗ рж╕рзЗржЗ goroutine ржХрзЗ wake ржХрж░рзЗред</li>
<li>ржПрж░ржкрж░ Go runtime ржПрж░ scheduler рж╕рзЗржЗ goroutine ржХрзЗ Local Run Queue рждрзЗ рж░рж╛ржЦрзЗред</li>
<li>ржПржХржЯрж┐ Logical Processor (P) рж╕рзЗржЗ goroutine ржЯрж┐ ржЪрж╛рж▓рж╛ржирзЛрж░ ржЬржирзНржп ржПржХржЯрж┐ dedicated OS thread (M) ржкрж╛ржпрж╝ред</li>
</ul>
<p><strong>ЁЯФ╣ ЁЯФБ Execution рж╢рзБрж░рзБ</strong></p>
<ul>
<li>рж╕рзЗржЗ Logical Processor ржПржЦржи main goroutine execute ржХрж░рзЗред</li>
<li>Go runtime fd 5 ржХрзЗ main goroutine ржПрж░ ржХрж╛ржЫрзЗ ржкрж╛ржарж╛ржпрж╝ред</li>
</ul>
<p><strong>ЁЯФ╣ ЁЯФН Data Read рж╣рзЯ</strong></p>
<ul>
<li>ржПржЦржи main goroutine fd 5 ржерзЗржХрзЗ data ржкржбрж╝рзЗ</li>
<li>socket receive buffer ржерзЗржХрзЗ data ржЖрж╕рзЗ</li>
<li>rw тЖТ data store рж╣рзЯ</li>
</ul>
<p><strong>ЁЯФ╣ ЁЯЪА Serve ржХрж░рж╛рж░ ржЬржирзНржп ржирждрзБржи goroutine рждрзИрж░рж┐</strong></p>
<ul>
<li>ржПрж░ржкрж░ Go runtime <code>go c.serve(connCtx)</code> ржХрж▓ ржХрж░рзЗ<br />
-ржирждрзБржи ржПржХржЯрж╛ goroutine рждрзИрж░рж┐ рж╣ржпрж╝</li>
</ul>
<p>ржПржЗ goroutine ржЯрж┐ rw рждрзЗ ржерж╛ржХрж╛ data ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ HTTP request handle ржХрж░рзЗред</p>
<p><strong>ЁЯФД ржкрж░ржмрж░рзНрждрзА request-ржПрж░ ржЬржирзНржп ржЕржкрзЗржХрзНрж╖рж╛</strong></p>
<ul>
<li>ржПрж░ржкрж░ main goroutine ржЖржмрж╛рж░ <code>l.Accept()</code> ржП ржпрж╛ржпрж╝ред</li>
<li>Go runtime ржЬрж╛ржирзЗ ржпрзЗ ржЖржЧрзЗржЗ socket (fd 5) рждрзИрж░рж┐ рж╣ржпрж╝рзЗржЫрзЗред</li>
<li>рж╕рзЗ ржПржЦржи new incoming request ржПрж░ ржЬржирзНржп ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗред</li>
</ul>
<p><strong>ЁЯФБ ржирждрзБржи data ржПрж▓рзЗ ржЖржмрж╛рж░рзЛ ржПржХржЗ cycle</strong></p>
<ul>
<li>
<p>NIC тЖТ kernel тЖТ socket receive buffer тЖТ mark fd ready тЖТ wake epoll_wait</p>
</li>
<li>
<p>Go runtime тЖТ wake goroutine тЖТ read тЖТ serve</p>
</li>
</ul>
<p>ржПржнрж╛ржмрзЗржЗ ржПржХржЯрж┐ HTTP server concurrency + efficiency рж╕рж╣ржХрж╛рж░рзЗ thousands of connections handle ржХрж░рждрзЗ ржкрж╛рж░рзЗред</p>
<pre><code class="language-markdown">Client Request (Browser)
тЖУ
Router тЖТ Server NIC тЖТ NIC Buffer (RAM)
тЖУ (Interrupt)
Linux Kernel тЖТ Copy to Socket Buffer (fd 5)
тЖУ
Mark fd 5 ready тЖТ Wake epoll_wait()
тЖУ
Go Runtime тЖТ Finds sleeping goroutine
тЖУ
Wake up тЖТ Scheduler тЖТ Local Run Queue тЖТ OS Thread
тЖУ
Execute main goroutine
тЖУ
main goroutine reads from fd 5 тЖТ rw = l.Accept()
тЖУ
go c.serve(connCtx) тЖТ spawn goroutine to handle
тЖУ
main goroutine again waits for next request...
</code></pre>
<h3 id="-newly-spawned-goroutine"><a class="header" href="#-newly-spawned-goroutine">ЁЯУж Newly Spawned goroutine</a></h3>
<ul>
<li>ржпржЦржи <code>go c.serve(connCtx)</code> ржПрж░ ржорж╛ржзрзНржпржорзЗ ржПржХржЯрж┐ ржирждрзБржи goroutine spawn ржХрж░рж╛ рж╣ржпрж╝,
рждржЦржи ржПржХржЯрж┐ ржирждрзБржи stack рждрзИрж░рж┐ рж╣ржпрж╝, ржПржмржВ ржПржЗ stack ржЯрж┐ heap memory ржПрж░ ржоржзрзНржпрзЗ рж╕ржВрж░ржХрзНрж╖рж┐ржд рж╣ржпрж╝ред</li>
<li>Go рждрзЗ goroutine ржПрж░ stack ржЫрзЛржЯ (ржкрзНрж░ржержорзЗ 2KB), ржХрж┐ржирзНрждрзБ ржПржЯрж┐ dynamic ржнрж╛ржмрзЗ ржмрж╛рзЬрждрзЗ ржкрж╛рж░рзЗред</li>
<li>ржПржЗ goroutine ржЯрж┐ рждрж╛рж░ржкрж░ local run queue рждрзЗ ржпрзБржХрзНржд рж╣ржпрж╝, ржпрзЗржЦрж╛ржирзЗ ржЕржирзЗржХ goroutine рж▓рж╛ржЗржи ржзрж░рзЗ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗред</li>
<li>ржкрзНрж░рждрж┐ржЯрж┐ logical processor (P) ржПрж░ рж╕рж╛ржерзЗ ржПржХржЯрж┐ dedicated OS thread (M) mapped ржерж╛ржХрзЗред ржПржЗ logical processor (P) рж╕рзЗржЗ local run queue ржерзЗржХрзЗ goroutine ржЯрж┐ржХрзЗ рждрзБрж▓рзЗ ржирзЗрзЯ ржПржмржВ execution рж╢рзБрж░рзБ ржХрж░рзЗред</li>
</ul>
<blockquote>
<p>ЁЯз╡ goroutine spawn = тАЬржирждрзБржи ржПржХржЯрж┐ lightweight thread рждрзИрж░рж┐ ржХрж░рзЗ рж╕рзЗржЯрж╛ржХрзЗ ржЪрж╛рж▓рзБ ржХрж░рж╛редтАЭ</p>
</blockquote>
<h3 id="-mux-ржПржмржВ-handler-execution-ржзрж╛ржк"><a class="header" href="#-mux-ржПржмржВ-handler-execution-ржзрж╛ржк">тЬЕ mux ржПржмржВ handler execution ржзрж╛ржк:</a></h3>
<ul>
<li>ржПрж░ ржЖржЧрзЗ server ржПрж░ ржоржзрзНржпрзЗ mux (ржпрзЗржоржи <code>http.NewServeMux()</code>) рждрзИрж░рж┐ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗ ржПржмржВ рж╕рзЗржЦрж╛ржирзЗ <code>HandleFunc()</code> ржПрж░ ржорж╛ржзрзНржпржорзЗ route ржУ handler function register ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред</li>
<li>goroutine ржУржЗ router-ржПрж░ ржоржзрзНржпрзЗ ржЦрзБржБржЬрзЗ ржжрзЗржЦрзЗ, request-ржПрж░ URL path /about ржПрж░ ржорждрзЛ ржХрзЛржи route ржПрж░ рж╕рж╛ржерзЗ match ржХрж░рзЗ ржХрж┐ржирж╛ред</li>
<li>ржирждрзБржи goroutine ржпржЦржи ржЪрж╛рж▓рзБ рж╣ржпрж╝, рждржЦржи request-ржПрж░ URL path, header, ржПржмржВ ржЕржирзНржпрж╛ржирзНржп metadata ржжрзЗржЦрзЗ ржмрзЛржЭрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзЗ, ржХрзЛржи route ржмрж╛ path ржЯрж┐ ржорж┐рж▓рзЗ ржпрж╛ржЪрзНржЫрзЗред</li>
<li>ржпржЦржи ржПржХржЯрж┐ HTTP request ржЖрж╕рзЗ, рждржЦржи router ржЪрзЗржХ ржХрж░рзЗ рж╕рзЗржЗ URL path ржПрж░ рж╕рж╛ржерзЗ ржХрзЛржи pattern match ржХрж░ржЫрзЗ ржПржмржВ рж╕рзЗржЗ ржЕржирзБржпрж╛ржпрж╝рзА handler function execute ржХрж░рзЗред
<ul>
<li>ржпрзЗржоржи goroutine ржУржЗ router-ржПрж░ ржоржзрзНржпрзЗ ржЦрзБржБржЬрзЗ ржжрзЗржЦрзЗ, request-ржПрж░ URL path <code>/about</code> ржПрж░ ржорждрзЛ ржХрзЛржи route ржПрж░ рж╕рж╛ржерзЗ match ржХрж░рзЗ ржХрж┐ржирж╛ред</li>
<li><code>/about</code> path ржПрж░ ржЬржирзНржп <code>aboutHandler()</code> ржирж╛ржорзЗрж░ handler function register ржХрж░рж╛ ржЖржЫрзЗред</li>
</ul>
</li>
<li>handler match рж╣ржмрж╛рж░ ржкрж░, рж╕рзЗржЗ matched handler function ржПрж░ ржЬржирзНржп ржПржХржЯрж┐ ржирждрзБржи stack frame рждрзИрж░рж┐ рж╣ржпрж╝, ржпрж╛рждрзЗ ржУржЗ ржлрж╛ржВрж╢ржиржЯрж┐ рждрж╛рж░ ржХрзЛржб execute ржХрж░рждрзЗ ржкрж╛рж░рзЗред
<ul>
<li>ржпржЦржи <code>aboutHandler()</code> ржЪрж╛рж▓рзБ рж╣рзЯ:
<ul>
<li>рждрж╛рж░ ржЬржирзНржп ржПржХржЯрж┐ ржирждрзБржи stack frame рждрзИрж░рж┐ рж╣ржпрж╝, ржпрж╛рждрзЗ ржлрж╛ржВрж╢ржирзЗрж░ ржнрж┐рждрж░рзЗрж░ ржХрзЛржб execute ржХрж░рж╛ ржпрж╛ржпрж╝ред</li>
<li>ржПржЗ ржлрж╛ржВрж╢ржи <code>w (response writer)</code> &amp; <code>fprintln</code> ржПрж░ ржорж╛ржзрзНржпржорзЗ socket ржПрж░ ржХрж╛ржЫрзЗ <code>"About page"</code> write ржХрж░рзЗред</li>
<li>socket send buffer ржП syscall ржПрж░ ржорж╛ржзрзНржпржорзЗ data store рж╣рзЯред</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="-nic-ржП-ржбрзЗржЯрж╛-ржпрж╛ржУрзЯрж╛рж░-ржкрж░рж╕рзЗрж╕"><a class="header" href="#-nic-ржП-ржбрзЗржЯрж╛-ржпрж╛ржУрзЯрж╛рж░-ржкрж░рж╕рзЗрж╕">ЁЯза NIC-ржП ржбрзЗржЯрж╛ ржпрж╛ржУрзЯрж╛рж░ ржкрзНрж░рж╕рзЗрж╕</a></h3>
<ul>
<li><strong>Go app ржерзЗржХрзЗ socket</strong>
<ul>
<li>fmt.Fprintln(w, "About page") тЖТ Go runtime ResponseWriter ржПрж░ ржнрж┐рждрж░рзЗ Write() method call ржХрж░рзЗ тЖТ ржЕржмрж╢рзЗрж╖рзЗ <code>syscall.Write()</code> ржПрж░ ржорж╛ржзрзНржпржорзЗ kernel <em>socket send buffer</em> ржП data ржЬржорж╛ рж╣рзЯред</li>
<li><code>ResponseWriter.Write()</code> тЖТ ржЕржмрж╢рзЗрж╖рзЗ Go syscall layer-ржП ржЧрж┐рзЯрзЗ syscall.Write() call рж╣рзЯред</li>
<li><code>syscall.Write()</code> ржПрж░ ржорж╛ржзрзНржпржорзЗ data kernel space-ржП ржпрж╛рзЯ ржПржмржВ Socket Send Buffer ржП ржЬржорж╛ рж╣рзЯред</li>
<li>Kernel рждржЦржи socket FD (File Descriptor) ржЕржирзБржпрж╛рзЯрзА check ржХрж░рзЗ data ready ржХрж┐ржирж╛ред</li>
</ul>
</li>
<li><strong>Kernel ржерзЗржХрзЗ NIC</strong>
<ul>
<li>Kernel-ржПрж░ network stack рж╕рзЗржЗ data ржХрзЗ ржкрзНржпрж╛ржХрзЗржЯ ржХрж░рзЗ (TCP/IP header рж╕рж╣) NIC-ржПрж░ <em>TX (Transmit) ring buffer</em>-ржП рж▓рзЗржЦрж╛ рж╣рзЯ (ржПржЯрж╛ <em>hardware circular queue</em>)ред</li>
</ul>
</li>
<li><strong>NIC ржкрзНржпрж╛ржХрзЗржЯ ржирзЗрзЯ ржПржмржВ Physical Layer-ржП ржкрж╛ржарж╛рзЯ</strong>
<ul>
<li>NIC Controller тЖТ DMA (Direct Memory Access) ржжрж┐рзЯрзЗ data ring buffer ржерзЗржХрзЗ ржкрзЬрзЗ тЖТ electromagnetic signal ржЖржХрж╛рж░рзЗ Ethernet cable / WiFi ржжрж┐рзЯрзЗ router/switch-ржПрж░ ржжрж┐ржХрзЗ ржкрж╛ржарж╛рзЯред</li>
</ul>
</li>
<li><strong>Router hopping</strong>
<ul>
<li>ржПржХрж╛ржзрж┐ржХ router, switch ржПржмржВ network node ржкрж╛рж░ рж╣рзЯрзЗ destination client (user-ржПрж░ PC ржмрж╛ mobile) ржкрж░рзНржпржирзНржд ржкрзМржБржЫрж╛рзЯред</li>
</ul>
</li>
<li><strong>Client receives</strong>
<ul>
<li>Client ржПрж░ NIC тЖТ OS тЖТ Browser тЖТ renders <strong>"About page"</strong></li>
</ul>
</li>
</ul>
<pre><code class="language-plaintext">+--------------------+               +-----------------+
|  Go Application    |               |     Kernel      |
|--------------------|               |-----------------|
| fmt.Fprintln(w,тАж)  |               |                 |
|   тЖУ                |               | syscall.Write() |
| ResponseWriter     |               |   тЖУ             |
|   тЖУ                |               | Socket Buffer   |
+--------------------+               |   тЖУ             |
                                     | NIC Driver      |
                                     +--------тЖУ--------+
                                              |
                           +------------------тЖУ-------------------+
                           |       NIC TX Ring Buffer (DMA)       |
                           +------------------тЖУ-------------------+
                                              |
                                 Electromagnetic Signal
                                              тЖУ
                                        Ethernet/WiFi
                                              тЖУ
                                           Router
                                              тЖУ
                                          Client PC
                                        "About page"

</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Term</th><th>Meaning</th></tr></thead><tbody>
<tr><td><strong>Socket</strong></td><td>2-way data pipe, communication endpoint</td></tr>
<tr><td><strong>File Descriptor (FD)</strong></td><td>kernel-assigned number for tracking sockets/files</td></tr>
<tr><td><strong>epoll_ctl</strong></td><td>kernel ржХрзЗ ржмрж▓рж┐ тАФ тАЬржПржЗ socket ready рж╣рж▓рзЗ ржЖржорж╛ржХрзЗ ржЬрж╛ржирж┐ржУтАЭ</td></tr>
<tr><td><strong>epoll_wait</strong></td><td>Go runtime waits here тАФ non-blocking</td></tr>
<tr><td><strong>goroutine</strong></td><td>Go-ржПрж░ ultra-light thread тАФ request handle ржХрж░рзЗ</td></tr>
</tbody></table>
</div>
<p>[<strong>Author:</strong> @nazma98
<strong>Date:</strong> 2025-07-30
<strong>Category:</strong> interview-qa/class-wise
]</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../interview-qna/class-wise/golang043-into-the-backend-development/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../interview-qna/topic-wise/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../interview-qna/class-wise/golang043-into-the-backend-development/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../interview-qna/topic-wise/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
