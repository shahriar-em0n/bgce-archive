# ЁЯУЪ ржХрзНрж▓рж╛рж╕ рзйрзз: Go Slice (Slice)

## ЁЯЪА ржорзВрж▓ ржмрж┐рж╖ржпрж╝рж╕ржорзВрж╣

- Slice ржХрзА?
- ржПржХржЯрж┐ Slice ржП ржХрзЯржЯрж┐ ржЕржВрж╢ ржерж╛ржХрзЗ?
- Slice ржПрж░ Pointer, Length, ржПржмржВ Capacity ржирж┐рж░рзНржгржпрж╝ ржХрж░рж╛
- ржмрж┐ржжрзНржпржорж╛ржи Array ржерзЗржХрзЗ Slice рждрзИрж░рж┐
- ржмрж┐ржжрзНржпржорж╛ржи Slice ржерзЗржХрзЗ ржирждрзБржи Slice рждрзИрж░рж┐
- Slice Literal (рж╕рж░рж╛рж╕рж░рж┐ ржШрзЛрж╖ржгрж╛)
- `make()` ржжрж┐ржпрж╝рзЗ Slice рждрзИрж░рж┐ (рж╢рзБржзрзБ length)
- `make()` ржжрж┐ржпрж╝рзЗ Slice рждрзИрж░рж┐ (length ржПржмржВ capacity)
- ржЦрж╛рж▓рж┐ ржмрж╛ Nil Slice рждрзИрж░рж┐
- Slice ржП ржирждрзБржи element ржпрзЛржЧ ржХрж░рж╛ (append)
- `append` ржХрж░рж╛рж░ рж╕ржоржпрж╝ ржЕржнрзНржпржирзНрждрж░рзАржг ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ (Heap ржПржмржВ Underlying Array)
- Underlying Array ржХрзАржнрж╛ржмрзЗ dynamic ржнрж╛ржмрзЗ ржмрж╛ржбрж╝рзЗ
- ржХрж┐ржЫрзБ ржоржЬрж╛рж░ ржЙржжрж╛рж╣рж░ржг ржПржмржВ ржЗржирзНржЯрж╛рж░ржнрж┐ржЙ ржкрзНрж░рж╢рзНржи
- Variadic Functions

---

# ЁЯза рзз. Slice ржХрзА?

- **Slice** рж╣рж▓рзЛ Go ржПрж░ ржПржХржЯрж┐ flexible data structureред
- ржПржЯрж┐ ржорзВрж▓ржд array ржПрж░ ржЙржкрж░рзЗ ржирж┐рж░рзНржорж┐ржд ржПржХржЯрж┐ **dynamic view**ред
- array ржПрж░ ржоржд рж╣рж▓рзЗржУ, slice ржПрж░ рж╕рж╛ржЗржЬ ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рж╛ ржпрж╛ржпрж╝ (ржмржбрж╝ ржмрж╛ ржЫрзЛржЯ ржХрж░рж╛ ржпрж╛ржпрж╝)ред

**ржорзВрж▓ ржкржпрж╝рзЗржирзНржЯ:**

- Slice, array ржиржпрж╝ред
- Slice, array ржПрж░ ржЙржкрж░рзЗ рждрзИрж░рж┐ рж╣ржпрж╝ред

---

# ЁЯФе рзи. ржПржХржЯрж┐ Slice ржПрж░ ржХрзЯржЯрж┐ ржЕржВрж╢ ржерж╛ржХрзЗ?

Slice ржорзВрж▓ржд ржПржХржЯрж┐ **struct** ржпрж╛ рждрж┐ржиржЯрж┐ ржЕржВрж╢ ржирж┐ржпрж╝рзЗ ржЧржарж┐ржд:

```go
struct Slice {
    pointer *T // points underlying array
    length  int // current elements number
    capacity int // maximum elements (until reallocation)
	}
```

Slice ржХрзЗ ржорзВрж▓ржд ржПржХржЯрж┐ array ржПрж░ "window" рж╣рж┐рж╕рзЗржмрзЗ ржнрж╛ржмрж╛ ржпрзЗрждрзЗ ржкрж╛рж░рзЗред

---

# ЁЯХ╡я╕ПтАНтЩВя╕П рзй. POinter, lenth ржПржмржВ capacity ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рж╛рж░ ржЙржкрж╛ржпрж╝

ржирж┐ржорзНржирзЛржХрзНржд built-in ржлрж╛ржВрж╢ржи ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ Slice ржПрж░ length ржПржмржВ capacity ржмрзЗрж░ ржХрж░рж╛ ржпрж╛рзЯ:

- `len(slice)` тЮбя╕П Length
- `cap(slice)` тЮбя╕П Capacity

ржЙржжрж╛рж╣рж░ржг:

```go
s := arr[1:4] // index 1 to 3
fmt.Println(len(s)) // 3
fmt.Println(cap(s)) //  index 1 to end of the array
```

---

# ЁЯПЧ рзк. Array ржерзЗржХрзЗ Slice рждрзИрж░рж┐ ржХрж░рж╛

```go
arr := [6]string{"This", "is", "a", "Go", "interview", "Questions"}
s := arr[1:4] // slice ["is", "a", "Go"]
```

- `pointer`: `arr` ржПрж░ index 1 ржирж┐рж░рзНржжрзЗрж╢ ржХрж░рзЗ
- `length`: 3 (index 1 to 3)
- `capacity`: 5 (index 1 to 5)

---

# ЁЯФД рзл. Slice ржерзЗржХрзЗ ржирждрзБржи Slice рждрзИрж░рж┐

```go
s1 := s[1:2] // Slice "a"
```

- `s1` Slice ржЯрж┐ ржПржХржЗ Array ржПрж░ ржПржХржЯрж┐ **view**!
- `s1` ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рж▓рзЗ `arr` ржПрж░ ржорж╛ржиржУ ржкрж░рж┐ржмрж░рзНрждрж┐ржд рж╣рждрзЗ ржкрж╛рж░рзЗред

---

# тЬНя╕П 6. Slice Literal

ржПржХржЯрж┐ Slice рждрзИрж░рж┐ ржХрж░рждрзЗ рж╕рж░рж╛рж╕рж░рж┐ ржорж╛ржи ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ ржпрж╛ржпрж╝, ржЖрж▓рж╛ржжрж╛ ржХрж░рзЗ Array рждрзИрж░рж┐ ржХрж░рж╛рж░ ржкрзНрж░ржпрж╝рзЛржЬржи ржирзЗржЗред

```go
s2 := []int{3, 4, 7}
```

## ржПржЦрж╛ржирзЗ Go automatically ржПржХржЯрж┐ underlying Array рждрзИрж░рж┐ ржХрж░рзЗред

# ЁЯПЧя╕П рзн. make() ржжрж┐ржпрж╝рзЗ ржПржХржЯрж┐ Slice рждрзИрж░рж┐ ржХрж░рж╛

```go
s3 := make([]int, 3)
```

- `make()` ржжрж┐рзЯрзЗ рзйржЯрж┐ рж╢рзВржирзНржп ржорж╛ржи (zero) рж╕рж╣ ржПржХржЯрж┐ Slice рждрзИрж░рж┐ ржХрж░рзЗред ржЕрж░рзНржерж╛рзО, рзйржЯрж┐ empty element ржерж╛ржХржмрзЗред
- `len = 3`, `cap = 3`

---

# ЁЯПЧя╕ПЁЯПЧя╕П рзо. `make()` ржжрж┐ржпрж╝рзЗ ржПржХржЯрж┐ Slice рждрзИрж░рж┐ ржХрж░рж╛ (length ржПржмржВ capacity)

```go
s4 := make([]int, 3, 5)
```

- `len = 3`, ржХрж┐ржирзНрждрзБ capacity `cap = 5` ржкрж░рзНржпржирзНржд рж╣рждрзЗ ржкрж╛рж░рзЗ reallocation ржПрж░ ржЖржЧ ржкрж░рзНржпржирзНржд

---

# ЁЯХ│ 9. Empty / Nil Slice Slice рждрзИрж░рж┐

```go
var s5 []int
```

- `len = 0`, `cap = 0`
- Still valid! ржПрждрзЗ ржирждрзБржи element ржпрзЛржЧ (append) ржХрж░рж╛ ржпрж╛ржмрзЗред

---

# тЮХ рззрзж. Slice ржП ржирждрзБржи element append ржХрж░рж╛

```go
s6 := append(s6, 1)
```

- Go ржирж┐ржЬрзЗ ржерзЗржХрзЗ underlying Array ржмрзЬ ржХрж░рзЗред
- _ржЕржирзЗржХ ржмрзЬ Array_ рждрзИрж░рж┐ ржПржмржВ ржЖржЧрзЗрж░ element ржЧрзБрж▓рзЛ copy ржХрж░рж╛рж░ ржХрж╛ржЬржУ ржХрж░рзЗ ржерж╛ржХрзЗред

---

# ЁЯзм рззрзз. append ржХрж░рж╛рж░ рж╕ржорзЯ ржЖрж╕рж▓рзЗ ржХрзА рж╣рзЯ?

ржпржЦржи ржПржХржЯрж┐ Slice ржПрж░ capacity ржкрзВрж░рзНржг рж╣рзЯ:

- ржПржХржЯрж┐ **ржирждрзБржи Array** (рж╕рж╛ржзрж╛рж░ржгржд ржжрзНржмрж┐ржЧрзБржг рж╕рж╛ржЗржЬрзЗрж░) рждрзИрж░рж┐ ржХрж░рж╛ рж╣рзЯред
- ржЖржЧрзЗрж░ Array ржПрж░ рж╕ржорж╕рзНржд elements ржирждрзБржи Array рждрзЗ ржХржкрж┐ ржХрж░рж╛ рж╣рзЯред

ржП ржХрж╛рж░ржгрзЗржЗ ржХржЦржиржУ ржХржЦржиржУ append ржХрж░рж╛ ржжрзНрж░рзБржд ржоржирзЗ рж╣рзЯ ржПржмржВ ржХржЦржиржУ ржмрзЬ ржорзЗржорж░рж┐ ржЕржкрж╛рж░рзЗрж╢ржи рждрзИрж░рж┐ ржХрж░рждрзЗ ржкрж╛рж░рзЗред

---

# ЁЯУИ рззрзи. Underlying Array ржХрж┐ржнрж╛ржмрзЗ ржмрзГржжрзНржзрж┐ ржкрж╛ржпрж╝:

**ржпрзЗ ржкрзНржпрж╛ржЯрж╛рж░рзНржирзЗ capacity ржкрж╛рзЯ (Capacity Growth Pattern):** (simplified)

- Cap 1 тЮбя╕П 2 тЮбя╕П 4 тЮбя╕П 8 тЮбя╕П 16 тЮбя╕П ...

ржПржЯрж┐ ржПржХржЯрж┐ optimization technique ржпрж╛ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рзЗ ржпрзЗржи append ржЕржкрж╛рж░рзЗрж╢ржиржЧрзБрж▓рзЛ ржЧржбрж╝рзЗ `O(1)` рж╕ржоржпрж╝рзЗ рж╕ржорзНржкржирзНржи рж╣ржпрж╝ред

---

# Go Slice ржмрзГржжрзНржзрж┐: `len` ржПржмржВ `cap` ржПрж░ dynamics ржмрзЛржЭрж╛

Go Slice ржПржХржЯрж┐ рж╢ржХрзНрждрж┐рж╢рж╛рж▓рзА ржПржмржВ flexible data structure, ржпрж╛ dynamic Array ржПрж░ ржорждрзЛ ржХрж╛ржЬ ржХрж░рзЗред ржПрж░ ржПржХржЯрж┐ ржорзВрж▓ ржмрзИрж╢рж┐рж╖рзНржЯрзНржп рж╣рж▓рзЛ, ржпржЦржи ржирждрзБржи element ржпрзЛржЧ ржХрж░рж╛ рж╣ржпрж╝, рждржЦржи Slice ржирж┐ржЬрзЗ ржирж┐ржЬрзЗржЗ ржмрзГржжрзНржзрж┐ ржкрж╛ржпрж╝ред Slice ржХрзАржнрж╛ржмрзЗ ржПржмржВ ржХржЦржи ржмрзГржжрзНржзрж┐ ржкрж╛ржпрж╝, ржЖрж░ ржПрж░ ржорзЗржорж░рж┐ ржЕрзНржпрж╛рж▓рзЛржХрзЗрж╢ржирзЗрж░ ржкржжрзНржзрждрж┐ ржмрзБржЭрж▓рзЗ ржЕржирзЗржХ efficient program design ржХрж░рж╛ рж╕ржорзНржнржмред

ржПржЦржи ржЖржорж░рж╛ Go Slice ржПрж░ ржмрзГржжрзНржзрж┐рж░ ржкржжрзНржзрждрж┐ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржХрж░ржм:

- ржпржжрж┐ Slice ржПрж░ `len` ржПржмржВ `cap` `1024`-ржПрж░ ржХржо рж╣ржпрж╝, рждрж╛рж╣рж▓рзЗ ржПржЯрж┐ рж╕рж╛ржзрж╛рж░ржгржд ржжрзНржмрж┐ржЧрзБржг (2x) ржмрзГржжрзНржзрж┐ ржкрж╛ржпрж╝ред
- `len` ржПржмржВ `cap`, `1024` ржЫрж╛ржбрж╝рж┐ржпрж╝рзЗ ржЧрзЗрж▓рзЗ, ржПржЯрж┐ ржкрзНрж░рж╛ржпрж╝ 25% рж╣рж╛рж░рзЗ ржмрзГржжрзНржзрж┐ ржкрж╛ржпрж╝ред
- Slice ржХрзЗржи ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржкрж░рж┐ржорж╛ржгрзЗ (ржпрзЗржоржи 1024 ржерзЗржХрзЗ 1280) ржирж╛ ржмрж╛ржбрж╝рж┐ржпрж╝рзЗ ржмржбрж╝ ржмрзНрж▓ржХрзЗ (ржпрзЗржоржи 1536) ржмрж╛ржбрж╝рзЗ, рж╕рзЗржЯрж┐ржУ ржмрзНржпрж╛ржЦрзНржпрж╛ ржХрж░рж╛ рж╣ржмрзЗред

## Slice Growth Overview

Go рждрзЗ slice ржорзВрж▓ржд array ржПрж░ ржЙржкрж░рзЗ ржнрж┐рждрзНрждрж┐ ржХрж░рзЗ ржХрж╛ржЬ ржХрж░рзЗред ржпржЦржи ржПржХржЯрж┐ slice ржП ржирждрзБржи element append ржХрж░рж╛ рж╣ржпрж╝, рждржЦржи ржкрзНрж░ржпрж╝рзЛржЬржирзЗ Go ржПржХржЯрж┐ ржмржбрж╝ array рждрзИрж░рж┐ ржХрж░рзЗ ржПржмржВ ржкрзБрж░рж╛ржирзЛ element ржЧрзБрж▓рзЛ рждрж╛рждрзЗ ржХржкрж┐ ржХрж░рзЗред ржПржЗ ржкрзНрж░рж╕рзЗрж╕ржЯрж┐ ржирж┐рж░рзНржнрж░ ржХрж░рзЗ Go ржХрж┐ржнрж╛ржмрзЗ ржирждрзБржи capacity ржирж┐рж░рзНржзрж╛рж░ржг ржХрж░рзЗ ржПржмржВ ржорзЗржорж░рж┐ allocate ржХрж░рзЗред

### рззрзи.рзз. ржЫрзЛржЯ Slice ржПрж░ ржХрзНрж╖рзЗрждрзНрж░рзЗ ржжрзНржмрж┐ржЧрзБржг ржмрзГржжрзНржзрж┐ (`len(cap) < 1024`)

ржпржЦржи slice ржЫрзЛржЯ ржерж╛ржХрзЗ (ржЕрж░рзНржерж╛рзО, ржПрж░ `len` ржПржмржВ `cap` ржжрзБржЯрзЛржЗ 1024 ржПрж░ ржХржо), рждржЦржи Go рж╕рж╛ржзрж╛рж░ржгржд capacity **ржжрзНржмрж┐ржЧрзБржг** ржХрж░рзЗред ржПрж░ ржорж╛ржирзЗ, ржпржЦржи slice ржП ржПржХржЯрж┐ element ржпрзЛржЧ ржХрж░рж╛ рж╣рзЯ ржПржмржВ ржирждрзБржи ржорзЗржорж░рж┐ ржкрзНрж░ржпрж╝рзЛржЬржи рж╣ржпрж╝, рждржЦржи Go ржЖржЧрзЗрж░ capacity ржПрж░ ржжрзНржмрж┐ржЧрзБржг ржЖржХрж╛рж░рзЗрж░ ржПржХржЯрж┐ ржирждрзБржи array рждрзИрж░рж┐ ржХрж░рзЗ ржПржмржВ ржкрзБрж░рж╛ржирзЛ element ржЧрзБрж▓рзЛ рж╕рзЗржЦрж╛ржирзЗ ржХржкрж┐ ржХрж░рзЗред Slice ржПрж░ `len` рзз ржмрж╛ржбрж╝ржмрзЗ, ржХрж┐ржирзНрждрзБ `cap` ржжрзНржмрж┐ржЧрзБржг рж╣ржмрзЗред

#### ржЙржжрж╛рж╣рж░ржг:

```go
s := []int{1, 2, 3}
fmt.Println(len(s), cap(s)) // len: 3, cap: 3

s = append(s, 4)
fmt.Println(len(s), cap(s)) // len: 4, cap: 6

s = append(s, 5)
fmt.Println(len(s), cap(s)) // len: 5, cap: 6
```

- ржкрзНрж░ржержорзЗ, slice ржПрж░ `len` рзй ржПржмржВ `cap` рзй ржерж╛ржХрзЗред
- ржЪрждрзБрж░рзНрже element ржпрзЛржЧ ржХрж░рж╛рж░ рж╕ржоржпрж╝, slice ржПрж░ capacity рзй ржерзЗржХрзЗ ржжрзНржмрж┐ржЧрзБржг рж╣ржпрж╝рзЗ рзм рж╣ржпрж╝рзЗ ржпрж╛ржпрж╝ред
- ржкрж░ржмрж░рзНрждрзА ржЕрзНржпрж╛ржкрзЗржирзНржбрзЗ, slice ржПрж░ capacity рзм ржЗ ржерж╛ржХржмрзЗ ржХрж╛рж░ржг `len` < `cap`ред

### рззрзи.рзи. ржмржбрж╝ Slice ржПрж░ ржХрзНрж╖рзЗрждрзНрж░рзЗ рзирзл% ржмрзГржжрзНржзрж┐ (`len(cap) >= 1024`)

ржпржЦржи slice ржПрж░ `len` ржПржмржВ `cap` 1024 ржмрж╛ рждрж╛рж░ ржмрзЗрж╢рж┐ рж╣ржпрж╝, рждржЦржи Go ржжрзНржмрж┐ржЧрзБржгрзЗрж░ ржкрж░рж┐ржмрж░рзНрждрзЗ ржмрж░рзНрждржорж╛ржи capacity ржПрж░ **рзирзл%** ржмрзГржжрзНржзрж┐ ржХрж░рзЗред ржПржЗ ржХрзМрж╢рж▓ржЯрж┐ ржШржи ржШржи ржорзЗржорж░рж┐ reallocation ржПржбрж╝рж╛рждрзЗ ржПржмржВ ржЕржкрзНрж░ржпрж╝рзЛржЬржирзАржпрж╝ ржорзЗржорж░рж┐ ржЕржкржЪржпрж╝ ржХржорж╛рждрзЗ рж╕рж╣рж╛ржпрж╝рждрж╛ ржХрж░рзЗред

#### ржЙржжрж╛рж╣рж░ржг:

```go
s := make([]int, 1024)  // len: 1024, cap: 1024
fmt.Println(len(s), cap(s))

s = append(s, 1025) // len: 1025, cap: 1280 (1024 + 25% of 1024)
fmt.Println(len(s), cap(s))

s = append(s, 1300) // len: 1300, cap: 1600 (1280 + 25% of 1280)
fmt.Println(len(s), cap(s))
```

- рж╢рзБрж░рзБрждрзЗ, ржЖржорж░рж╛ length ржПржмржВ capacity 1024 рж╕рж╣ ржПржХржЯрж┐ slice рждрзИрж░рж┐ ржХрж░рж┐ред
- ржкрж░рзЗрж░ element append ржХрж░рж▓рзЗ slice ржПрж░ capacity 1024 ржерзЗржХрзЗ 1280 рж╣ржпрж╝, ржпрж╛ 1024 ржПрж░ рж╕рж╛ржерзЗ рзирзл% ржпрзЛржЧ ржХрж░рзЗ ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝ред
- ржЖрж░рзЗржХржЯрж┐ element append ржХрж░рж▓рзЗ capacity 1600 рж╣ржпрж╝ (1280 ржПрж░ рж╕рж╛ржерзЗ рзирзл% ржпрзЛржЧ ржХрж░рзЗ)ред

### рззрзи.рзй. ржорзЗржорж░рж┐ ржмрзНрж▓ржХрзЗрж░ ржнрзВржорж┐ржХрж╛ (ржпрзЗржоржи, 1536 ржХрзНрж╖ржорждрж╛рж░ Slice)

ржпржЦржи slice ржПрж░ `len` ржПржмржВ `cap` 1024 ржПрж░ ржХрж╛ржЫрж╛ржХрж╛ржЫрж┐ ржмрж╛ рждрж╛рж░ ржмрзЗрж╢рж┐ рж╣ржпрж╝, рждржЦржи Go рж╕рж░рзНржмржжрж╛ ржирж┐ржЦрзБржБржд ржЧржгржирж╛ ржЕржирзБржпрж╛ржпрж╝рзА ржорзЗржорж░рж┐ ржмрж░рж╛ржжрзНржж ржХрж░рзЗ ржирж╛ред ржПрж░ ржкрж░рж┐ржмрж░рзНрждрзЗ ржПржЯрж┐ рж╕рж┐рж╕рзНржЯрзЗржо ржорзЗржорж░рж┐ ржмрж░рж╛ржжрзНржжрзЗрж░ ржзрж░ржг ржЕржирзБржпрж╛ржпрж╝рзА **Optimal Memory Block** ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗред

ржЙржжрж╛рж╣рж░ржгрж╕рзНржмрж░рзВржк, ржпржжрж┐ ржПржХржЯрж┐ slice ржПрж░ capacity 1024 ржПрж░ ржХрж╛ржЫрж╛ржХрж╛ржЫрж┐ ржерж╛ржХрзЗ, ржкрж░ржмрж░рзНрждрзА ржмрж░рж╛ржжрзНржж рж╕рж░рж╛рж╕рж░рж┐ 256 ржпрзЛржЧ ржХрж░рзЗ 1280 ржирж╛ рж╣ржпрж╝рзЗ, ржПрж░ ржерзЗржХрзЗ ржмржбрж╝ 1536 ржПрж░ ржорждрзЛ ржмрзНрж▓ржХрзЗ рж╣рждрзЗ ржкрж╛рж░рзЗред ржПржЯрж┐ ржмржбрж╝ ржорзЗржорж░рж┐ ржмрзНрж▓ржХрзЗрж░ ржЬржирзНржп ржЖрж░ржУ ржХрж╛рж░рзНржпржХрж░ ржорзЗржорж░рж┐ ржмрзНржпржмрж╣рж╛рж░рзЗ рж╕рж╣рж╛ржпрж╝рждрж╛ ржХрж░рзЗред

#### ржХрзЗржи 1536 ржПрж░ ржкрж░рж┐ржмрж░рзНрждрзЗ 1280?

ржПржЯрж┐ ржорзВрж▓ржд **Hardware Memory Alignment** ржПрж░ ржЙржкрж░ ржирж┐рж░рзНржнрж░ ржХрж░рзЗред 1536 рж╕ржВржЦрзНржпрж╛ржЯрж┐ ржмрзЗржЫрзЗ ржирзЗржУржпрж╝рж╛ рж╣ржпрж╝ ржХрж╛рж░ржг ржПржЯрж┐ рж╕рж╛ржзрж╛рж░ржгржд 2-ржПрж░ ржЧрзБржгрж┐рждржХ ржЖржХрж╛рж░рзЗрж░ ржорзЗржорж░рж┐ ржмрзНрж▓ржХрзЗрж░ рж╕рж╛ржерзЗ ржнрж╛рж▓рзЛржнрж╛ржмрзЗ ржорж┐рж▓рзЗ ржпрж╛ржпрж╝ ржПржмржВ ржЖржзрзБржирж┐ржХ CPU ржПржмржВ ржорзЗржорж░рж┐ рж╕рж┐рж╕рзНржЯрзЗржорзЗрж░ ржЬржирзНржп optimize ржХрж░рж╛ред ржорзЗржорж░рж┐ ржЕрзНржпрж╛рж▓рзЛржХрзЗрж╢ржи рж╕рж╛ржзрж╛рж░ржгржд рж╕рж┐рж╕рзНржЯрзЗржорзЗрж░ memory page size ржмрж╛ cache line ржПрж░ рж╕рж╛ржерзЗ рж╕рж╛ржоржЮрзНржЬрж╕рзНржп рж░рзЗржЦрзЗ ржмржбрж╝ ржмрзНрж▓ржХрзЗ ржХрж░рж╛ рж╣ржпрж╝, ржпрж╛ ржорзЗржорж░рж┐ ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ржХрзЗ ржЖрж░ржУ ржЗржлрж┐рж╢рж┐рзЯрзЗржирзНржЯ ржХрж░рзЗ рждрзЛрж▓рзЗред

#### ржЙржжрж╛рж╣рж░ржг (memory alignment):

```go
s := make([]int, 1024) // len: 1024, cap: 1024
fmt.Println(len(s), cap(s)) // 1024, 1024

s = append(s, 1025) // len: 1025, cap: 1536 (next optimal block size)
fmt.Println(len(s), cap(s)) // 1025, 1536
```

- 1024 ржерзЗржХрзЗ 1536 ржП capacity ржмрзГржжрзНржзрж┐ рж╣ржпрж╝, ржХрж╛рж░ржг 1536 ржПржХржЯрж┐ ржмрзЗржЯрж╛рж░ ржорзЗржорж░рж┐ ржмрзНрж▓ржХ ржпрж╛ рж╕рж┐рж╕рзНржЯрзЗржорзЗрж░ ржЗржлрж┐рж╢рж┐рзЯрзЗржирзНржЯ ржорзЗржорж░рж┐ ржЕрзНржпрж╛рж▓рзЛржХрзЗрж╢ржи ржХрж░рзЗред

### рззрзи.рзк. ржХрзЗржи ржПржоржи рж╣ржпрж╝?

**efficiency considerations** Go рж╕рж░рж╛рж╕рж░рж┐ 256 ржХрж░рзЗ ржмрзГржжрзНржзрж┐ ржХрж░рзЗ ржирж╛ (ржпрзЗржоржи ржЖржорж░рж╛ ржоржирзЗ ржХрж░рж┐ 1024 ржерзЗржХрзЗ 1280)ред ржХрж╛рж░ржг ржПржЯрж┐ ржЗржлрж┐рж╢рж┐рзЯрзЗржирзНрж╕рж┐ ржмрзГржжрзНржзрж┐рж░ ржЬржирзНржп ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржгред ржПржЗ ржЕрзНржпрж╛рж▓рзЛржХрзЗрж╢ржи рж╕рзНржЯрзНрж░рзНржпрж╛ржЯрзЗржЬрж┐рж░ ржлрж▓рзЗ ржШржи ржШржи рж░рж┐-ржЕрзНржпрж╛рж▓рзЛржХрзЗрж╢ржи ржПржбрж╝рж╛ржирзЛ ржпрж╛ржпрж╝ ржПржмржВ ржЕржкрзНрж░ржпрж╝рзЛржЬржирзАржпрж╝ ржорзЗржорж░рж┐ ржЕржкржЪржпрж╝ ржХржорзЗ ржпрж╛ржпрж╝ред ржмрж░ржВ ржмржбрж╝ ржмрзНрж▓ржХрзЗ (1536) ржорзЗржорж░рж┐ ржмрж░рж╛ржжрзНржж ржХрж░рзЗ Go рж░рж╛ржиржЯрж╛ржЗржо ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рзЗ SliceрзЗ ржкрж░рзНржпрж╛ржкрзНржд capacity ржЖржЫрзЗ ржЖрж░ржУ element ржПржкрзЗржирзНржб ржХрж░рж╛рж░ ржЬржирзНржп ржПржмржВ ржЦрзБржм рждрж╛рзЬрж╛рждрж╛рзЬрж┐ SliceржХрзЗ ржмрж╛рзЬрж╛рждрзЗ рж╣ржмрзЗ ржирж╛ред

ржПрж░ ржлрж▓рзЗ ржЖрж░ржУ ржнрж╛рж▓рзЛ performance ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝, ржмрж┐рж╢рзЗрж╖ ржХрж░рзЗ ржпржЦржи slice ржжрзНрж░рзБржд ржмрзГржжрзНржзрж┐ ржкрж╛ржпрж╝ред

## Conclusion

Go-ржПрж░ slice ржмрзГржжрзНржзрж┐ ржХрзМрж╢рж▓ ржЕржирзЗржХ ржЗржлрж┐рж╢рж┐рзЯрзЗржирзНржЯ ржХрзЛржб рж▓рж┐ржЦрж╛ рж╕ржорзНржнржмред ржЫрзЛржЯ рж╕рж╛ржЗржЬрзЗрж░ slice ржПрж░ ржХрзНрж╖рзЗрждрзНрж░рзЗ, Go capacity ржжрзНржмрж┐ржЧрзБржг ржХрж░рзЗ ржпрж╛рждрзЗ ржХржо рж░рж┐-ржЕрзНржпрж╛рж▓рзЛржХрзЗрж╢ржирзЗ ржЖрж░ржУ element ржзрж╛рж░ржг ржХрж░рждрзЗ ржкрж╛рж░рзЗред ржмржбрж╝ slice (1024 ржПржмржВ ржПрж░ ржмрзЗрж╢рж┐) рж╣рж▓рзЗ, ржПржЯрж┐ capacity рзирзл% ржмрзГржжрзНржзрж┐ ржХрж░рзЗ ржПржмржВ ржорж╛ржЭрзЗ ржорж╛ржЭрзЗ ржЕржкрзНржЯрж┐ржорж╛рж▓ ржорзЗржорж░рж┐ ржмрзНрж▓ржХрзЗрж░ рж╕рж╛ржерзЗ рж╕рж╛ржоржЮрзНржЬрж╕рзНржп рж░рж╛ржЦрзЗред ржПржЗ ржкржжрзНржзрждрж┐ржЯрж┐ slice ржХрзЗ ржжрзНрж░рзБржд ржПржмржВ ржорзЗржорж░рж┐ рж╕рж╛рж╢рзНрж░ржпрж╝рзА ржХрж░рзЗ рждрзЛрж▓рзЗред

---

# ЁЯдпрззрзй. ржХрж┐ржЫрзБ ржЗржирзНржЯрж╛рж░рзЗрж╕рзНржЯрж┐ржВ ржЗржирзНржЯрж╛рж░ржнрж┐ржЙ ржкрзНрж░рж╢рзНржирзЗрж░ ржЙржжрж╛рж╣рж░ржг

### тЪб Same Underlying Array Trick

```go
var x []int
x = append(x, 1)
x = append(x, 2)
x = append(x, 3)

y := x
x = append(x, 4)
y = append(y, 5)

x[0] = 10
fmt.Println(x)
fmt.Println(y)
```

-x ржПржмржВ y ржПржХржЗ backing array рж╢рзЗржпрж╝рж╛рж░ ржХрж░рзЗ

- ржПржХржЯрж┐рждрзЗ ржкрж░рж┐ржмрж░рзНрждржи (mutation) ржХрж░рж▓рзЗ ржжрзБржЯрзЛрж░ржЗ ржорж╛ржи ржкрж░рж┐ржмрж░рзНрждрж┐ржд рж╣рждрзЗ ржкрж╛рж░рзЗред

ржХрж┐ржирзНрждрзБ `cap` ржЕрждрж┐ржХрзНрж░ржо ржХрж░рзЗ ржЕрзНржпрж╛ржкрзЗржирзНржб ржХрж░рж▓рзЗ, рждрж╛рж░рж╛ ржЖрж▓рж╛ржжрж╛ Array рждрзЗ ржмрж┐ржнржХрзНржд рж╣рждрзЗ ржкрж╛рж░рзЗред

# ЁЯЫа рззрзк. Variadic Functions

ржХрзЛржи ржлрж╛ржВрж╢ржи `...` (ellipsis) operator ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржЕрж╕ржВржЦрзНржп argument receive ржХрж░рждрзЗ ржкрж╛рж░рзЗред

```go
func variadic(numbers ...int) {
    fmt.Println(numbers)
}

variadic(2, 3, 4, 6, 8, 10)
```

ржПржЦрж╛ржирзЗ `numbers` ржХрж┐ржирзНрждрзБ ржПржХржЯрж┐ **slice**!

---

# ЁЯза RAM ржП Slice ржПрж░ visualization (arr ржПржмржВ s ржПрж░ ржЬржирзНржп)

```
Array arr (indexes):
[0] "This"
[1] "is"  <- s.ptr points here
[2] "a"
[3] "Go"
[4] "interview"
[5] "Questions"

Slice s:
- ptr = &arr[1]
- len = 3 ("is", "a", "Go")
- cap = 5 (from "is" to "Questions")
```

Memory Visualization:

```
+----+--+-+--+---------+---------+
|This|is|a|Go|interview|Questions|
+----+--+-+--+---------+---------+
       ^ ^  ^
     s[0] s[1] s[2]
```

---

# ЁЯУД Full Code with Detailed Comments

```go
package main

import "fmt"

func main() {
	// Create an array of strings
	arr := [6]string{"This", "is", "a", "Go", "interview", "Questions"}
	fmt.Println(arr)

	// Create a slice from array indexes 1 to 3 (exclusive of 4)
	s := arr[1:4]
	fmt.Println(s) // [is a Go]

	// Create a slice from a slice
	s1 := s[1:2]
	fmt.Println(s1) // [a]
	fmt.Println(len(s1)) // 1
	fmt.Println(cap(s1)) // 4 (capacity depends on the underlying array)

	// Slice literal
	s2 := []int{3, 4, 7}
	fmt.Println("slice", s2, "lenght:", len(s2), "capacity:", cap(s2))

	// make() function with length only
	s3 := make([]int, 3)
	s3[0] = 5
	fmt.Println(s3)
	fmt.Println(len(s3))
	fmt.Println(cap(s3))

	// make() function with length and capacity
	s4 := make([]int, 3, 5)
	s4[0] = 5
	fmt.Println(s4)
	fmt.Println(len(s4))
	fmt.Println(cap(s4))

	// Empty slice
	var s5 []int
	fmt.Println(s5) // []

	// Appending elements to empty slice
	var s6 []int
	s6 = append(s6, 1)
	fmt.Println(s6) // [1]

	var s7 []int
	s7 = append(s7, 1, 2, 3)
	fmt.Println(s7, len(s7), cap(s7)) // [1 2 3] 3 3

	// Interview question: Sharing underlying array
	var x []int
	x = append(x, 1)
	x = append(x, 2)
	x = append(x, 3)

	y := x
	x = append(x, 4)
	y = append(y, 5)

	x[0] = 10

	fmt.Println(x) // [10 2 3 5]
	fmt.Println(y) // [10 2 3 5]

	// Another interview question
	slc := []int{1, 2, 3, 4, 5}
	slc = append(slc, 6)
	slc = append(slc, 7)

	slcA := slc[4:]

	slcY := changeSlice(slcA)

	fmt.Println(slc)  // [1 2 3 4 10 6 7]
	fmt.Println(slcY) // [10 6 7 11]
	fmt.Println(slc[0:8]) // [1 2 3 4 10 6 7 11]

	// Variadic function call
	variadic(2, 3, 4, 6, 8, 10)
}

// Function that changes the slice passed
func changeSlice(a []int) []int {
	a[0] = 10
	a = append(a, 11)
	return a
}

// Variadic function that takes multiple integers
func variadic(numbers ...int) {
	fmt.Println(numbers)
	fmt.Println(len(numbers))
	fmt.Println(cap(numbers))
}
```

[**Author:** @ifrunruhin12, @nazma98
**Date:** 2025-05-01 - 2025-05-18
**Category:** interview-qa/class-wise
]
